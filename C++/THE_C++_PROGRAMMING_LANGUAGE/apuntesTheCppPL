Apuntes sobre el libro:

The C++ programming language - Fourth edition 
Bjarne Stroustrup
ISBN 978-0-321-56384


################################################################################
######### Part I: Introductory Material ########################################
################################################################################

#############################
######## 2 TheBasics ########
############################# 

****************************************************
****** 2.2.2 Types, Variables, and Arithmetic ******
****************************************************

C++ tiene dos formas de realizar inicializaciones

int i1 = 7.2; // i1 becomes 7
int i2 {7.2}; // error : floating-point to integer conversion
int i3 = {7.2}; // error : floating-point to integer conversion (the = is 
                // redundant)

Se recomienda usar {} para prevenir errores, ya que devuelve errores y no 
realiza conversiones de tipos.

---

La palabra auto sirve para que el tipo de una variable se defina en el momento 
de la inicializacion durante la compilacion del programa.

auto b = true; //a bool
auto ch = 'x'; //a char
auto i = 123; //an int
auto d = 1.2; //a double
auto z = sqrt(y); //z has the type of whatever sqr t(y) returns

*****************************
****** 2.2.3 Constants ******
*****************************

const sirve para indicar que el valor no deberia ser cambiado. Se usa 
principalmente en interfaces, para que los datos pasados a las funciones no se 
cambien. Indica "solo lectura".

constexpr indica al compilador que el valor de esa variable va a ser constante y
puede ser calculado en tiempo de compilacion para un mejor rendimiento.

const int dmv = 17; //dmv is a named constant
int var = 17; //var is not a constant
constexpr double max1 = 1.4∗square(dmv); //OK if square(17) is a constant exp
constexpr double max2 = 1.4∗square(var); //error : var is not a constant exp
const double max3 = 1.4∗square(var); //OK, may be evaluated at run time
double sum(const vector<double>&); //sum will not modify its argument (§2.2.5)
vector<double> v {1.2, 3.4, 4.5}; //v is not a constant
const double s1 = sum(v); //OK: evaluated at run time
constexpr double s2 = sum(v); //error : sum(v) not constant expression

constexpr tambien se puede usar en funciones que pueden calcular su valor de 
retorno en tiempo de compilacion y se pueden utilizar en contextos donde se 
requiera valores constantes.

constexpr double square(double x) { return x∗x; }

const permite definiciones anticipadas mientras que constexpr no.
La diferencia mas importante es que ambas aseguran que el valor va a ser 
constante, pero constexpr asegura que va a ser calculado en tiempo de 
compilacion y const no. Por eso ciertas aserciones o calculos constantes solo
van a funcionar con constexpr.

***********************************************
****** 2.2.5 Pointers, Arrays, and Loops ******
***********************************************

En las declaraciones, [] significa "array de" y * significa "puntero a".
El valor del tamano de un array debe ser una constante.

--

nullptr es introducido en C++11 y sirve para indicar que un puntero apunta a un 
objeto no valido o a ningun objeto. nullptr es de tipo nullptr_t y sirve para 
cualquier tipo de dato. 

double∗ pd = nullptr;
Link<Record>∗ lst = nullptr; //pointer to a Link to a Record
int x = nullptr; //error : nullptr is a pointer not an integer

En C NULL es un entero, por lo que nullptr nos permite una mejor gestion de 
punteros nulos.

********************************
****** 2.3.3 Enumerations ******
********************************

Los enum class permiten definir mejor enumerados porque encierran sus valores en
su propio scope, para evitar confusiones como podria pasar con enum de C.

enum class Color { red, blue, green };
enum class Traffic_light { green, yellow, red };

Color col = Color::red;
Traffic_light light = Traffic_light::red;

Los enum class guardan enteros.

Son fuertemente tipados y seguros:

Color col = Color::red;
Traffic_light light = Traffic_light::red;

Por defecto permiten realizar asignacion, inicializacion y comparacion, pero se 
pueden definir operadores propios porque un enum class es un user-defined type:

Traffic_light& operator++(Traffic_light& t)
    // prefix increment: ++
{
    switch (t) {
        case Traffic_light::green: return t=Traffic_light::yellow;
        case Traffic_light::yellow: return t=Traffic_light::red;
        case Traffic_light::red: return t=Traffic_light::green;
    }
}
Traffic_light next = ++light; //
next becomes Traffic_light::green

******************************
****** 2.4.2 Namespaces ******
******************************

Los namespaces se utlizan para organizar codigo muy grande. Permiten definir 
funciones que se van a poder usar en ese espacio de nombres y pueden tener el 
mismo nombre que otas funciones en otro namespace.

namespace My_code {
    class complex { /*...*/ };
    complex sqrt(complex);
    //    ...
    int main();
}

int My_code::main()
{
    complex z {1,2};
    auto z2 = sqrt(z);
    std::cout << '{' << z2.real() << ',' << z2.imag() << "}\n";
    //    ...
};
    
int main()
{
    return My_code::main();
}


**********************************
****** 2.4.3 Error Handling ******
**********************************

-- 2.4.3.1 Exceptions

Se pueden lanzar excepciones en el codigo y capturar y tratar en un bloque try 
catch.

double& Vector::operator[](int i)
{
    if (i<0 || size()<=i) throw out_of_range{"Vector::operator[]"};
    return elem[i];
}

throw transfiere el control al manejador de excepciones del tipo out_of_range.

out_of_range esta definido en la libreria estandar.


-- 2.4.3.2 Invariants

Las invariantes son condiciones que se deben cumplir durante el ciclo de vida de 
un objeto. Es recomendable utilizarlas para tener un diseño robusto y evitar 
errores.

Por ejemplo en el constructor de un vector, comprobar que el tamano del vector 
indicado es mayor que 0.


-- 2.4.3.3 Static Assertions

Las excepciones se reportan en tiempo de ejecucion. Para realizar comprobaciones 
en tiempo de compilacion se usa static_assert

static_assert(A,S); imprime S como error del compilador si A no es cierto.

static_assert(4<=sizeof(int), "integers are too small"); //check integer size 

Se suele utilizar para comprobar los tipos pasados como parametro en la 
programacion generica.



#####################################
###### 3 AbstractionMechanisms ######
#####################################

@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 3.2 Classes @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@

**********************************
****** 3.2.1 Concrete Types ******
**********************************

-- 3.2.1.1 An Arithmetic Type

Observacion: los constructores en C++ pueden usar una notacion conocida como 
lista de inicializacion para inicializar los valores pasados por parametro de la 
siguiente forma:

class complex {
    double re, im; //    representation: two doubles
    public:
    complex(double r, double i) :re{r}, im{i} {} // construct complex from two 
                                                 // scalars
    complex(double r) :re{r}, im{0} {} //    construct complex from one scalar
    complex() :re{0}, im{0} {} //    default complex: {0,0}
    double real() const { return re; }
    void real(double d) { re=d; }
    double imag() const { return im; }
    void imag(double d) { im=d; }
    complex& operator+=(complex z) { re+=z.re, im+=z.im; return ∗this; } 
    // add to re and im
    //    and return the result
    complex& operator−=(complex z) { re−=z.re, im−=z.im; return ∗this; }
    complex& operator∗=(complex); //    defined out-of-class somewhere
    complex& operator/=(complex); //    defined out-of-class somewhere
};

complex(double r, double i) :re{r}, im{i} {} asigna a re y im los valores de r e
i.


-- 3.2.1.2 A Container

Un contenedor es un objeto que contiene una coleccion de elementos, como vector. 
Este tipo de objetos alocan nuevos elementos con new, pero no los desalocan 
nunca. Es por eso que hay que crear destructores en la ausencia de un recolector 
de basura.

˜Vector() { delete[] elem; } // Destructor de Vector

Para destruir un objeto se usa la palabra delete. Un objeto se destruye 
automaticamente al llegar al cierre de la funcion donde es definido.


-- 3.2.1.3 Initializing Containers

Hay varias formas de rellenar un contenedor con objetos:
    Constructor del tipo std::initializer_list : Es un constructor que provee la 
    liberia estandar y es creado por el compilador al usar la sintaxis:
        Vector v1 = {1, 2, 3} (uso de {})
    push_back(): anade elementos al final de la lista


**********************************
****** 3.2.2 Abstract Types ******
**********************************

Los concrete types como Vector o complex son llamados asi porque su 
representacion es parte de su definicion.
Un abstract type es un tipo que deja la parte de la implementacion a cargo del 
usuario.

Ejemplo: se define una clase Container como una version abstracta de Vector:

class Container {
public:
    virtual double& operator[](int) = 0; //    pure virtual function
    virtual int size() const = 0;        //    const member function (§3.2.1.1)
    virtual ˜Container() {}              //    destructor (§3.2.1.2)
};

Esta clase es una interfaz pura para especificar contenedores mas tarde.

La palabra virtual significa "puede ser redefinida mas tarde en una clase 
derivada de esta".

La sintaxis =0 indica que la funcion es "pure virtual", esto significa que las 
clases derivadas de Container deben definir esa funcion.


Implentacion de la clase:

class Vector_container : public Container { 
    // Vector_container implements Container
    Vector v;
public:
    Vector_container(int s) : v(s) { } //Vector of s elements   
    ˜Vector_container() {}
    double& operator[](int i) { return v[i]; }
    int size() const { return v.size(); }
};


*************************************
****** 3.2.3 Virtual Functions ******
*************************************

La resolución de la función virtual ocurre en tiempo de ejecución.
Cuando se llama a una función virtual a través de un puntero o referencia de la 
clase base, se ejecuta la implementación de la clase derivada si se ha 
sobrescrito.
Esto permite que el comportamiento de la función se adapte al tipo real del 
objeto en tiempo de ejecución, lo que facilita el polimorfismo y la manipulación 
de objetos de diferentes tipos de manera uniforme.


*************************************
****** 3.2.4 Class Hierarchies ******
*************************************

Una clase que hereda o implementa otra clase se define como 

class Circle : public Shape {}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 3.3 Copy and Move @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

**************************************
****** 3.3.1 Copying Containers ******
**************************************

Una forma incorrecta de copiar objetos contenedores es usar la asignacion o 
copia por defecto

void bad_copy(Vector v1)
{
    Vector v2 = v1; //    copy v1’s representation into v2
    v1[0] = 2;      //    v2[0] is now also 2!
    v2[1] = 3;      //    v1[1] is now also 3!
}

La forma correcta de hacerlo es definiendo nuestro propio constructor copia y 
sobreescribiendo el operador de asignacion.

class Vector {
private:
    double∗ elem; //elem points to an array of sz doubles
    int sz;
public:
    Vector(int s); //constructor: establish invariant, acquire resources
    ˜Vector() { delete[] elem; } //destructor: release resources
    Vector(const Vector& a); //copy constructor
    Vector& operator=(const Vector& a); //copy assignment
    double& operator[](int i);
    const double& operator[](int i) const;
    int size() const;
};

Vector::Vector(const Vector& a) //copy constructor
    :elem{new double[sz]}, //allocate space for elements
    sz{a.sz}
{
    for (int i=0; i!=sz; ++i) //copy elements
        elem[i] = a.elem[i];
}

Vector& Vector::operator=(const Vector& a) //copy assignment
{
    double∗ p = new double[a.sz];
    for (int i=0; i!=a.sz; ++i)
        p[i] = a.elem[i];
    delete[] elem; //delete old elements
    elem = p;
    sz = a.sz;
    return ∗this;
}


*************************************
****** 3.3.2 Moving Containers ******
*************************************

Para vectores con un tamano muy grande conviene moverlos al realizar ciertas 
operaciones en vez de copiarlos porque puede ser muy costoso.

class Vector {
    //...
    Vector(const Vector& a); //copy constructor
    Vector& operator=(const Vector& a); //copy assignment
    
    Vector(Vector&& a); //move constructor
    Vector& operator=(Vector&& a); //move assignment
};

Al definir la asignacion y constructor para mover, el compilador elegira estas 
opciones para retornar valores calculados en una funcion.


Construtor de movimiento

Vector::Vector(Vector&& a)
    :elem{a.elem}, //"grab the elements" from a
     sz{a.sz}
{
    a.elem = nullptr; //now a has no elements
    a.sz = 0;
}

En este caso se "roba" los elementos (el puntero) y el tamano de A, sin 
necesidad de copiar todos los elementos. A pone a nullptr su puntero porque al 
ser un valor temporal (rvalue) va a ser destruido, y no queremos que destruya 
los elementos que se acaba de asignar quien haya llamado al constructor move.

&& significa referencia a rvalue. 


La utilidad std::move incorporada en C++11 permite realizar un movimiento entre 
dos valores sin crear copias innecesarias. Es equivalente a hacer un static cast 
a una referencia a rvalue.
Ej: y = std::move(x); // no se crea una copia intermedia. Y pasa a tener los 
datos de x (movimiento con rvalue) y x apunta a un nullptr.
std::move indica al compilador que realize un movimiento de rvalues. 

Ejemplo de uso de std::move para mover un valor al final de un vector en vez de 
copiarlo:
    vector.push_back(std::move(elemento));


!!!!!!NOTAS SOBRE RVALUE:

lvalue es algo que existe en memoria y que podemos obtener su direccion. Es algo 
a lo que se puede asignar un valor. 

rvalue es algo que no tiene una direccion de memoria y no le podemos asignar 
cosas. Es un valor temporal. Es todo lo que no es lvalue.

Los rvalue solo existen dentro del alcance de la expresion en la que se 
utilizan. Y desaparecen tras la evalucion de la expresion.

Un rvalue puede ser el valor de return de una funcion.

Explicacion: https://www.youtube.com/watch?v=exCYowIIZ6s
Explicacion corta: https://www.youtube.com/watch?v=THr5NPqAVLM


******************************************
****** 3.3.4 Suppressing Operations ******
******************************************

Usar operaciones de copy o move en una jerarquia de clases suele ser un desastre 
porque no sabemos quien estara heredando la clase y si se necesita hacer algo 
adicional. Por eso se recomienda en estos casos eliminar el constructor y 
operador de copy y de move:

class Shape {
public:
    Shape(const Shape&) =delete; //    no copy operations
    Shape& operator=(const Shape&) =delete;
    
    Shape(Shape&&) =delete; //    no move operations
    Shape& operator=(Shape&&) =delete;
    
    ˜Shape();
    //    ...
};

Ahora si se intenta copiar un Shape, el compilador mostrara un aviso u error.

Si se necesita copiar un objeto de la jerarquia Shape, habria que crear algun 
tipo de funcion clone para la clase en especifico.

=delete es un mecanismo general y se puede usar para suprimir cualquier 
operacion.


@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 3.4 Templates @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@

#######################################
###### 3.4.1 Parameterized Types ######
#######################################

template<typename T>
class Vector {
private:
    T∗ elem; //    elem points to an array of sz elements of type T
    int sz;
public:
    Vector(int s); //    constructor: establish invariant, acquire resources
    ˜Vector() { delete[] elem; } //    destructor: release resources
  
    //    ... copy and move operations ...
  
    T& operator[](int i);
    const T& operator[](int i) const;
    int size() const { return sz; }
};

El sufijo template<typename T> equivale a la expresion matematica "para todos 
los tipos de T".

Las funciones de Vector tambien deberan declararse con una sintaxis similar:

template<typename T>
Vector<T>::Vector(int s)
{
    if (s<0) throw Negative_size{};
    elem = new T[s];
    sz = s;
}

template<typename T>
const T& Vector<T>::operator[](int i) const
{
    if (i<0 || size()<=i)
    throw out_of_range{"Vector::operator[]"};
    return elem[i];
}


**************************************
****** 3.4.2 Function Templates ******
**************************************

Se puede utilizar un template para una funcion, asi podemos generalizarla para 
poder utilizar con diferentes tipos de parametros:

template<typename Container, typename Value>
Value sum(const Container& c, Value v)
{
    for (auto x : c)
        v+=x;
    return v;
}


************************************
****** 3.4.3 Function Objects ******
************************************

Los function object , tambien llamados como functor, es una forma de definir
objetos para que puedan ser llamados como una funcion.

template<typename T>
class Less_than {
    const T val; //    value to compare against
public:
    Less_than(const T& v) :val(v) { }
    bool operator()(const T& x) const { return x<val; } //    call operator
};

Implementacion de la template:

Less_than<int> lti {42}; //lti(i) will compare i to 42 using < (i<42)
Less_than<string> lts {"Backus"}; 
//lts(s) will compare s to "Backus" using < (s<"Backus")

Utilzacion de estos functor:

void fct(int n, const string & s)
{
    bool b1 = lti(n); //    true if n<42
    bool b2 = lts(s); //    true if s<"Backus"
    //    ...
}

**************************************
****** 3.4.4 Variadic Templates ******
**************************************

Una variadic template es una template que puede recibir un numero arbitrario
de argumentos de tipos arbitrarios.

template<typename T, typename... Tail>
void f(T head, Tail... tail)
{
    g(head); //do something to head
    f(tail...); //tr y again with tail
}

void f() { } //do nothing


La clave de este uso de plantillas es que se puede separar lo que se hace con
la cabeza (primer argumento) y lo que se hace con la  cola (resto de argumentos)


***************************
****** 3.4.5 Aliases ******
***************************

Los alias se pueden aplicar a tipos o a plantillas. Se utiliza la palabra using.

using size_t = unsigned int;


El sistema de alias se puede utilizar para definir nuevos tipos de plantillas:

template<typename Key, typename Value>
class Map {
    //...
};

template<typename Value>
using String_map = Map<string,Value>;

String_map<int> m; //m is a Map<string,int>


#######################################
###### 4 ContainersAndAlgorithms ######
#######################################

@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 4.1 Libraries @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@

*********************************************
****** 4.1.1 Standard-Library Overview ******
*********************************************

Las facilidades que ofrece la libreria estandar se clasifican en:

    -Run-time language support (Ej: informacion de tipos en tiempo de ejecucion)
    -La libreria estandar de C, con ligeras modificaciones
    -Strings y IO streams
    -Un framework de contenedores y algoritmos conocido com STL.
    -Soporte para computacion numerica.
    -Soporte para expresiones regulares
    -Soporte para programacion concurrente con threads y locks.
    -Soporte para metaprogramacion con templates. Programacion generica.
    -Smart pointers y una interfaz para recolectores de basura.
    -Contenedores de proposito especial como array, bitset y tuple.


@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 4.3 Stream IO @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@

**************************
****** 4.3.1 Output ******
**************************

El operador << "poner en" se usa como operador de salida en objetos del tipo
ostream como cout.


*************************
****** 4.3.2 Input ******
*************************

El operador >> "obtener de" se usa como operador de entrada en objetos de tipo 
istream como cin.


********************************************
****** 4.3.3 IO of User-Defined Types ******
********************************************

Dado un tipo creado por el usuario, se pueden sobrescribir los operadores
<< y >> para imprimir los atributos del tipo o lo que queramos. Ejemplo:

struct Entry {
    string name;
    int number;
};

ostream& operator<<(ostream& os, const Entry& e)
{
    return os << "{\"" << e.name << "\", " << e.number << "}";
}

istream& operator>>(istream& is, Entry& e)
//read { "name" , number } pair. Note: formatted with { " " , and }
{
    char c, c2;
    if (is>>c && c=='{' && is>>c2 && c2=='"') { //star t with a { "
        string name; //the default value of a string is the empty string: ""
        while (is.get(c) && c!='"') //anything before a " is part of the name
            name+=c;
        
        if (is>>c && c==',') {
            int number = 0;
            if (is>>number>>c && c=='}') { //read the number and a }
                e = {name,number}; //assign to the entry
                return is;
            }
        }
    }
    is.setf(ios_base::failbit); //register the failure in the stream
    return is;
}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 4.4 Containers @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@

**************************
****** 4.4.1 vector ******
**************************

Siempre hay que indicar el tamano de un vector:

vector<int> v1 = {1, 2, 3, 4}; //size is 4
vector<string> v2; //size is 0
vector<Shape∗> v3(23); //size is 23; initial element value: nullptr
vector<double> v4(32,9.9); //size is 32; initial element value: 9.9

Los elementos de un vector se incian al valor por defecto de cada tipo (0, 
nullptr, etc), salvo que se indique otro valor como argumento.

push_back() anade al final un elemento e incrementa en 1 el tamano del vector


-- 4.4.1.1 Elements

Al introducir un elemento en un vector su valor se copia en el vector, no se
introduce una referencia o puntero, el valor directamente se copia.


-- 4.4.1.2 Range Checking

Por defecto Vector no tiene chequeo de rango al usar [] y puede dar lugar a 
errores inesperados al intentar obtener un valor fuera de rango.

Se recomienda realizar una implementacion de Vector donde se compruebe el 
rango, o comprobar el rango en el codigo.

El metodo vector::at() SI tiene comprobacion de rango y se recomienda su uso


************************
****** 4.4.2 list ******
************************

list es una lista doblemente enlazada. 
Se utiliza cuando no queremos mover los elementos de la lista.


***********************
****** 4.4.3 map ******
***********************

map esta implementado como un arbol binario balanceado. Cada elemento tiene
un puntero a otros dos, y ademas tiene una clave y un valor.


*********************************
****** 4.4.4 unordered_map ******
*********************************

El coste de un lookup a un mapa es de O(log(n)) donde n es el numero de 
elementos del mapa.
Esta cifra se puede mejorar con un unordered map.

En lugar de utilizar un funcion de ordenacion se comprueba una tabla hash
donde hay punteros a todos los nodos.


**************************************
****** 4.4.5 Container Overview ******
**************************************

Los contenedores incluidos en la libreria estandar son:

vector<T> A variable-size vector (§31.4)
list<T> A doubly-linked list (§31.4.2)
forward_list<T> A singly-linked list (§31.4.2)
deque<T> A double-ended queue (§31.2)
set<T> A set (§31.4.3)
multiset<T> A set in which a value can occur many times (§31.4.3)
map<K,V> An associative array (§31.4.3)
multimap<K,V> A map in which a key can occur many times (§31.4.3)
unordered_map<K,V> A map using a hashed lookup (§31.4.3.2)
unordered_multimap<K,V> A multimap using a hashed lookup (§31.4.3.2)
unordered_set<T> A set using a hashed lookup (§31.4.3.2)
unordered_multiset<T> A multiset using a hashed lookup (§31.4.3.2)

Cada uno esta en una liberia como <vector> <list> <map>.

Tambien se provee adaptadores de contenedores queue<T>, stack<T>, deque<T> y 
priority_queue<T>. Y de contenedores especializados como array<T,N> (array fijo) 
y bitset<N>.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 4.5 Algorithms @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@

************************************
****** 4.5.1 Use of Iterators ******
************************************

El algoritmo estandar find busca un valor en una secuencia y devuelve un
iterador al elemento encontrado. EJemplo: 

bool has_c(const string& s, char c) //does s contain the character c?
{
    auto p = find(s.begin(),s.end(),c);
    if (p!=s.end())
        return true;
    else
        return false;
}

find devuelve end() si no encuentra el elemento.


**************************************
****** 4.5.5 Algorithm Overview ******
**************************************

En la cabecera <algorithm> de std se encuentran los algoritmos:

p=find(b,e,x) p is the first p in [b:e) so that ∗p==x
p=find_if(b,e,f) p is the first p in [b:e) so that f(∗p)==true
n=count(b,e,x) n is the number of elements ∗q in [b:e) so that ∗q==x
n=count_if(b,e,f) n is the number of elements ∗q in [b:e) so that f(∗q,x)
replace(b,e,v,v2) Replace elements ∗q in [b:e) so that ∗q==v by v2
replace_if(b,e,f,v2) Replace elements ∗q in [b:e) so that f(∗q) by v2
p=copy(b,e,out) Copy [b:e) to [out:p)
p=copy_if(b,e,out,f) Copy elements ∗q from [b:e) so that f(∗q) to [out:p)
p=unique_copy(b,e,out) Copy [b:e) to [out:p); don’t copy adjacent duplicates
sort(b,e) Sort elements of [b:e) using < as the sorting criterion
sort(b,e,f) Sort elements of [b:e) using f as the sorting criterion
(p1,p2)=equal_range(b,e,v) [p1:p2) is the subsequence of the sorted sequence [b:e)
with the value v; basically a binary search for v
p=merge(b,e,b2,e2,out) Merge two sorted sequences [b:e) and [b2:e2) into [out:p)

Video: https://www.youtube.com/watch?v=kmykBI_dZxQ&list=PLEtcGQaT56cjJWLMsy-UCQ05zogAp7zbQ&index=114


#######################################
###### 5 ConcurrencyAndUtilities ######
#######################################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 5.2 Resource Management @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

*********************************************
****** 5.2.1 unique_ptr and shared_ptr ******
*********************************************

En la cabecera estandar <memory> se definen dos tipos de "smart pointers":

unique_ptr para representar propiedad unica
shared_ptr para representar propiedad compartida

Los smart pointers se usan principalmente para prevenir memory leaks.

unique_ptr asegura que el puntero sera destruido cuando se salga del scope.
unique_ptr libera la memoria del objeto al que apunta cuando es destruido.
unique_ptr usa semantica de movimiento para hacer return.

shared_ptr se copia en vez de moverse como el unique_ptr.
Los shared_ptr de un Object comparte la propiedad del Object y el objeto es
destruido cuando el ultimo de sus shared_ptr es destruido.

Un unique_ptr es unico, y no se puede copiar para pasar como parametro porque
esto implicaria tener dos copias de un puntero "unico".

Cuando usar smart pointers:
    Si queremos compartir un objeto -> shared_ptr
    Si queremos referirnos a un objeto polimorfico -> unique_ptr
    Un objeto compartido polimorfico -> shared_ptr
    
Para crear un shared_ptr, en C++11 se recomienda usar std::make_shared<>. Esto 
solo se hace cuando se crea el primer shared_ptr, el resto deberian crear una 
copia, por ejemplo auto ptr2 { ptr1 };

La idea de los smart pointers es no tener new y delete en el codigo.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 5.3 Concurrency @@@@@@ 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

*************************************
****** 5.3.1 Tasks and threads ******
*************************************

Un task es una computacion que puede ser ejecutada juntoo a otras 
computaciones concurrentemente.
Un thread es una representacion a nivel de sistema de una task en un 
programa.
Un task es una function o un objeto function.

#include <thread>

void f(); // function

struct F {             // function object
    void operator()(); // F's call operator
};

void user() 
{
    thread t1 {f};   // f() executes in separate thread
    thread t1 {F()}; // F()() executes in separate thread
    
    t1.join(); // wait for t1
    t2.join(); // wait for t2
}

Los threads comparte un unico espacio de direcciones.


*************************************
****** 5.3.2 Passing Arguments ******
*************************************

void f(vector<double>& v); //function do something with v

struct F { //function object: do something with v
    vector<double>& v;
    F(vector<double>& vv) :v{vv} { }
    void operator()(); //application operator ;
};
int main()
{
    vector<double> some_vec {1,2,3,4,5,6,7,8,9};
    vector<double> vec2 {10,11,12,13,14};
    
    thread t1 {f,some_vec}; //f(some_vec) executes in a separate thread
    thread t2 {F{vec2}}; //F(vec2)() executes in a separate thread
    
    t1.join();
    t2.join();
}

*************************************
****** 5.3.3 Returning Results ******
*************************************

//take input from v; place result in *res
void f(const vector<double>& v, double∗ res); 

class F {
public:
    F(const vector<double>& vv, double∗ p) :v{vv}, res{p} { }
    void operator()(); // place result in *res
private:
    const vector<double>& v; //source of input
    double∗ res; //target for output
};

int main()
{
    vector<double> some_vec;
    vector<double> vec2;
    //    ...
    
    double res1;
    double res2;
    
    thread t1 {f,some_vec,&res1};
    // f(some_vec,&res1) executes in a separate thread
    thread t2 {F{vec2,&res2}}; 
    // F{vec2,&res2}() executes in a separate thread
    
    t1.join();
    t2.join();
    
    cout << res1 << ' ' << res2 << '\n';
}


********************************
****** 5.3.4 Sharing Data ******
********************************

Para compartir datos entre hilos se necesita una herramienta de 
sincronizacion. La principal solucion es un mutex, que se adquiere usando
lock()


mutex m; //controlling mutex
int sh; //shared data

void f()
{
    unique_lock<mutex> lck {m}; //acquire mutex
    sh += 7; //manipulate shared data
} //release mutex implicitly

El constructor unique_lock se encarga de hacer m.lock() y m.unlock cuando 
m vaya a ser utilizado.

Las utilidades de mutex y lock se encuentran en <mutex>

-- 5.3.4.1 Waiting for Events

Las condition_variable permite que un thread espere a que otro thread termine
El soporte de estas condiciones se encuentra en <condition_variable>

Ejemplo:

class Message { //object to be communicated
    //...
};

queue<Message> mqueue; //the queue of messages
condition_variable mcond; //the variable communicating events
mutex mmutex; //the locking mechanism

void consumer()
{
    while(true) {
        unique_lock<mutex> lck{mmutex}; // acquire mmutex
        while (mcond.wait(lck)) /* do nothing */; // release lck and wait;
                                            // re-acquire lck upon wakeup
        auto m = mqueue.front(); // get the message
        mqueue.pop();
        lck.unlock(); // release lck
        // ... process m ...
    }
}

void producer()
{
    while(true) {
        Message m;
        //    ... fill the message ...
        unique_lock<mutex> lck {mmutex}; //    protect operations
        mqueue.push(m);
        mcond.notify_one(); //    notify
    } //    release lock (at end of scope)
}


***************************************
****** 5.3.5 Communicating Tasks ******
***************************************

-- 5.3.5.1 future and promise

Cuando un task quiere pasar un valor a otro task, lo pone en un promise
Cuando esto pasa, la implementacion hace que el valor aparezca en un future
de manera que pueda ser leido por el otro task.

             task 1            task 2     _ set_value()
    get() -> Future            promise --|_ set_exception()
                <---> value <--->

La promise existe para proporcionar metodos "put"
El future existe para proporcionar un metodo para hacer get de esos valores

void f(promise<X>& px) //a task: place the result in px
{
    //...
    try {
        X res;
        //... compute a value for res ...
        px.set_value(res);
    }
    catch (...) { //oops: couldn’t compute res
        //pass the exception to the future’s thread:
        px.set_exception(current_exception());
    }
}

void g(future<X>& fx) //a task: get the result from fx
{
    //...
    try {
        X v = fx.get(); //if necessary, wait for the value to get computed
        //... use v ...
    }
    catch (...) { //oops: someone couldn’t compute v
    //... handle error ...
    }
}

-- 5.3.5.2 packaged_task

double accum(double∗ beg, double ∗ end, double init)
//compute the sum of [beg:end) starting with the initial value init
{
    return accumulate(beg,end,init);
}

double comp2(vector<double>& v)
{
    using Task_type = double(double∗,double∗,double); //type of task
    
    packaged_task<Task_type> pt0 {accum}; //package the task (i.e., accum)
    packaged_task<Task_type> pt1 {accum};
    
    future<double> f0 {pt0.get_future()}; //get hold of pt0’s future
    future<double> f1 {pt1.get_future()}; //get hold of pt1’s future
    
    double∗ first = &v[0];
    thread t1 {move(pt0),first,first+v.size()/2,0}; //star t a thread for pt0
    thread t2 {move(pt1),first+v.size()/2,first+v.size(),0}; 
    //star t a thread for pt1
    
    //...
    
    return f0.get()+f1.get(); //get the results
}

-- 5.3.5.3 async()

double comp4(vector<double>& v)
//spawn many tasks if v is large enough
{
    if (v.size()<10000) return accum(v.begin(),v.end(),0.0);
    
    auto v0 = &v[0];
    auto sz = v.size();
    auto f0 = async(accum,v0,v0+sz/4,0.0); //    first quarter
    auto f1 = async(accum,v0+sz/4,v0+sz/2,0.0); //    second quarter
    auto f2 = async(accum,v0+sz/2,v0+sz∗3/4,0.0); //    third quarter
    auto f3 = async(accum,v0+sz∗3/4,v0+sz,0.0); //    four th quar ter
    
    return f0.get()+f1.get()+f2.get()+f3.get(); 
    // collect and combine the results
}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 5.4 Small Utility Components @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

************************
****** 5.4.1 Time ******
************************

using namespace std::chrono; //see §35.2

auto t0 = high_resolution_clock::now();
do_work();
auto t1 = high_resolution_clock::now();
cout << duration_cast<milliseconds>(t1−t0).count() << "msec\n";

Las utilidades del tiempo se encuentran en <chrono> bajo en namespace 
std::chrono

**********************************
****** 5.4.2 Type Functions ******
**********************************

Las type functions son funciones evaluadas en tiempo de compilacion.
Este tipo de progamacion se conoce como metaprogramming y se basa en realizar
la mayor parte de la computacion en tiempo de compilacion.

-- 5.4.2.1 iterator_traits

Las plantillas iterator_traits ofrecen utilidades para identificar 
diferentes tipos de iteradores. Con etiquetas como random_access_iterator_tag 
y forward_iterator_tag

-- 5.4.2.2 Type Predicates

La cabecera <type_traits> contiene utilidades sobre los tipos como:
bool b1 = Is_arithmetic<int>();


**********************************
****** 5.4.3 pair and tuple ******
**********************************

Pair y tuple se encuentran en <utility>

pair ofrece la posibilidad de juntar dos objetos diferetnes en un solo 
objeto. El pair se puede devolver como resultado de una funcion permitiendo
devolver dos objetos a la vez.

tuple es lo mismo pero para mas de dos objetos juntos.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 5.5 Regular Expressions @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

El soporte para expresiones regualares se encentra en <regex>
Es similar al uso en otros lenguajes.

int lineno = 0;
for (string line; getline(cin,line);) { //read into line buffer
    ++lineno;
    smatch matches; //matched strings go here
    if (regex_search(line,matches,pat)) //search for pat in line
        cout << lineno << ": " << matches[0] << '\n';
}

Los matches que se encuentren que cumplan el patron pat, se guardan en la 
variable de tipo smatch.


@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 5.6 Math @@@@@@
@@@@@@@@@@@@@@@@@@@@@@

*********************************************************
****** 5.6.1 Mathematical Functions and Algorithms ******
*********************************************************

En <cmath> se encuentran funciones matematicas habituales
En <complex> se encuentran las mismas funciones para numeros complejos.
En <numeric> se encuentran algoritmos numericos como accumulate()


***********************************
****** 5.6.2 Complex Numbers ******
***********************************

El tipo de datos complex esta definido por una template
Esta es utilizada por datos como Float y Double.
Sobre este tipo de datos se pueden realizar la mayoria de operaciones que 
se realizar sobre tipos no complejos.


**********************************
****** 5.6.3 Random Numbers ******
**********************************

El soprote para numeros aleatorios se encuentra en <random>
Un numero aleatorio consta de:
    1. Un engine que produce una secuencia de numeros pseudo-aleatorios
    2. Una distribution que mapea esos valores en una distribucion 
        matematica en un rango.
        Ejemplos de distribuciones son uniform_int_distribution,
        normal_distribution (curva de campana), exponential_distribution,etc.
Ejemplo:

using my_engine = default_random_engine; //type of engine
using my_distribution = uniform_int_distribution<>; //type of distribution

my_engine re {}; //the default engine
my_distribution one_to_six {1,6}; //distribution that maps to the ints 1..6
auto die = bind(one_to_six,re); //make a generator

int x = die(); //roll the die: x becomes a value in [1:6]

La funcion bind() crea un function object que invoca a su primer argumento
tomando su segundo argumento, es decir, en este caso die() es lo mismo que 
escribir one_to_six(re);


*************************************
****** 5.6.4 Vector Arithmetic ******
*************************************

La libreria estandar ofrece en <valarray> el tipo de datos valarray que es
como un vector pero menos general y mas optimizado para computacion numerica


**********************************
****** 5.6.5 Numeric Limits ******
**********************************

La cabecera <limits> provee de clases que describen propiedades de los tipos
definidos en la libreria estandar.
Una de esas propiedades son los limites.


######################################
###### 6 Types and Declarations ######
######################################

@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 6.2 Types @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@

**************************
***** 6.2.2 Booleans *****
**************************

Los integers se pueden convertir a boolean: si tienen un valor distinto de 
cero equivalen a true

Un puntero se puede convertir implicitamente a boolean.
Si vale nullptr equivale a false, por ejemplo:
    int *p;
    if (p) ...
    
    
*********************************
***** 6.2.3 Character Types *****
*********************************
    
 - char : suele ser de 8 bits
 - signed char : garantiza tener signo
 - unsigned char : garantiza no tener signo
 - wchar_t : para guardar caracteres largos. Su tamano depende de la 
 implementacion
 - char16_t : para set de caracteres de 16 bits (pe UTF-16)
 - char32_t    
    

*******************************
***** 6.2.4 Integer Types *****
*******************************

Cada tipo de integer tiene tres formas: plain, signed y unsigned.
Cada tipo de integer tiene cuatro tamanos: short int, "plain" int,
long int y long long int.

Los unsigned son ideales para bit arrays. Hay que usarlos solo 
cuando sean necesarios porque es facil que conduzcan a errores o 
desbordamientos que se pueden evitar con signed.

plain ints son siempre signed.

Para un mayor control sobre el tamano de los int, se pueden usar los
alias de <cstdint> como 
    - int64_t: signed int con 64 bits exactos
    - uint_fast16_t: unsigned int de 8 bits. Es el mas rapido.
    
    
**************************************
***** 6.2.5 Floating-Point Types *****
**************************************
    
 - float : single-precision
 - double: double-precision
 - long double: extended-precision
 
 
-- 6.2.5.1 Floating-Point Literals

Por defecto un floating-point literal es de tipo double.

Para indicar al compilador que queremos un tipo float se debe poner f o F al
final del literal:  3.14159265f , 2.0f

Para indicar que queremos un long double se debe poner l o L al final del 
literal: 3.14159265l , 2.0L
 
    
**********************
***** 6.2.7 void *****
**********************
    
void es un tipo fundamental, pero no hay objetos de tipo void.

void x;   // error: there are no void objects
void& r;  // error: there are no references to void
void f(); // function f does not return a value (§12.1.4)
void∗ pv; // pointer to object of unknown type (§7.2.1) 


***********************
***** 6.2.8 Sizes *****
***********************
   
Con sizeof se puede obtener el tamano de un tipo.
    
char : tamano de los caracteres de la implementacion (8 bit normalmente)
int : tamano de palabra (4 bytes actualmente)

La libreria <limits> contiene los limites de tamano de cada tipo.
Las funciones de esta libreria son constexpr por lo que no producen overhead

size_t es un tipo unsigned integer que sirve para almacenar el tamano 
de cualquier objeto. Se encuentra en <cstddef>  


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 6.3 Declarations @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

********************************
***** 6.3.5 Initialization *****
********************************

Para inicializar un objeto a partir de otro hay varias formas:
X a1 {v};
X a2 = {v};
X a3 = v;
X a4(v);
La primera forma es la ideal porque se puede usar en cualquier contexto y es 
menos propensa a errores.

Cuando se usa auto es mejor utilizar el inicializador = para que asigne el tipo
correcto:
auto z1 {99}; // z1 is an initializer_list<int>
auto z2 = 99; // z2 is an int

Para inicializar una variable con el valor por defecto se pueden usar {}


-- 6.3.5.1 Missing Initializers

Cuando una variable no se inicializa explicitamente, se inicializa con {} 
implicitamente:
int a;    // means ‘‘int a{};’’ so that a becomes 0
double d; // means ‘‘double d{};’’ so that d becomes 0.0

Si se quiere inizializar variables locales de un built-in type u objeto creados
con ese built-in type se recomienda usar {}:

void ff()
{
int x {};         // x becomes 0
char buf[1024]{}; // buf[i] becomes 0 for all i

int∗ p {new int{10}};       // *p becomes 10
char∗ q {new char[1024]{}}; // q[i] becomes 0 for all i

// ...
}

-- 6.3.5.2 Initializer Lists

Los objetos complicados que requieren mas de un valor para inicializarse suelen
usar initiaziler lists. 

En una declaracion () significa funcion, mientras que {} significa 
inicializacion por defecto:

complex<double> z1(1,2);  // function-style initializer (initialization by 
                          // constructor)
complex<double> f1();     // function declaration

complex<double> z2 {1,2}; // initialization by constructor to {1,2}
complex<double> f2 {};    // initialization by constructor to the default value 
                          // {0,0}

Al usar auto, {}-list se deduce a std::initializer_list<T>:
auto x1 {1,2,3,4};         // x1 is an initializer_list<int>
auto x2 {1.0, 2.25, 3.5 }; // x2 is an initializer_list of<double>
auto x3 {1.0,2};          // error: cannot deduce the type of {1.0,2} (§6.3.6.2)


******************************************************
***** 6.3.6 Deducing a Type: auto and decltype() *****
******************************************************

Hay dos mecanismos para deducir un tipo a partir de una expresion:
 - auto: para deducir el tipo de un objeto a partir de su inicializacion. El 
 tipo puede ser una variable, un const o un constexpr.
 - decltype(expr): para deducir un tipo de algo que no se inicializa como el 
 return type de una funcion o el tipo de un miembro de una clase.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 6.4 Objects and Values @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Un objeto es un region contigua de memoria. Un lvalue es una expresion que se
refiere a un objeto.

*************************************
***** 6.4.1 Lvalues and Rvalues *****
*************************************

Un rvalue es tipicamente todo lo que no es lvalue.
Hay dos propiedades importantes cuando se trata de mover, copiar o direccionar
un objeto:
 - Has identity: el programa tiene el nombre de, puntero a, o referencia de el 
 objeto. Asi que es posible determinar si dos objetos son iguales, cuando el 
 valor del objeto cambia, etc.
 - Movable: el objeto puede ser movido.
Hay tres posibles combinaciones que describen el funcionamiento de C++ (un 
objeto que no tiene identidad y no puede ser movido no es contemplado).
Usando m para movable y i para identity se puede representar graficamente:

lvalue (i&!m)       xvalue(i&m)      prvalue(!i&m)
           ^        ^        ^       ^
           |        |        |       |
           glvalue (i)       rvalue(m)

Un lvalue clasico es algo que tiene identidad pero no puede ser movido.
Un rvalue clasico es algo que se puede mover.
Otras alternativas son prvalue (pure rvalue), glvalue (generalized lvalue) y
xvalue (extraordinary/expert value). 
Para programacion practica es suficiente con entender lvalue y rvalue.
Un objeto puede ser lvalue o rvalue, pero no ambas.

    
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 6.5 Type Aliases @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Para definir alias se puede usar typedef o using. Son equivalentes:

using int32_t = int;
typedef int int32_t;

La unica diferencia es que using se puede usar con templates.



################################################
###### 7 Pointers, Arrays, and References ######
################################################



@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 7.5 Pointers and const @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

La palabra const se puede poner antes o depues del puntero, haciendo constante
el puntero o el objeto al que apunta.

void f1(char∗ p)
{
    char s[] = "Gorm";
    
    const char∗ pc = s; // pointer to constant
    pc[3] = 'g'; // error : pc points to constant
    pc = p; // OK
    
    char ∗const cp = s; // constant pointer
    cp[3] = 'a'; // OK
    cp = p; // error : cp is constant
    
    const char ∗const cpc = s; // const pointer to const
    cpc[3] = 'a'; // error : cpc points to constant
    cpc = p; // error : cpc is constant
}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 7.7 References @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Las referencias exiten para solucionar algunos problemas con los punteros.
El acceso a una referencia se hace de la misma forma que el acceso a un objeto.
No existe null-reference. Una referencia siempre se refiere a un objeto 
inicializado.

Hay tres tipos de referencias:
 - lvalue references: a un objeto que queremos cambiar
 - const references: a un objeto cuyo valor no queremos cambiar
 - rvalue references: a un objeto cuyo valor no queremos preservar despues de
 usarlo (un temporal).

Usualmente lvalue y const references se suelen llamar lvalue reference a ambas.


*************************************
****** 7.7.1 Lvalue References ******
*************************************

Para asegurar que una lvalue reference apunte a algo se tiene que inicializar
siempre. Inicializar una lvalue reference es diferente a asignarla. Ningun 
operador opera sobre un referencia. No es obligatorio que las referencias ocupen
espacio en memoria: el compilador trata de sustituir sus apariciones por el 
objeto al que referencia, pero a veces es necesario utilizar espacio en memoria

El inicializador de un T& debe ser un lvalue del tipo T. El inicializador de un
const T& no necesita no ser un lvalue ni siquiera del tipo T. En ambos casos:
 - Primero se aplica una conversion implicita a T si fuera necesario.
 - Despues el valor resultante es almacenado en una variable temporal del tipo
 T
 - Por ultimo el valor temporal es usado como valor para el inicializador. 

double& dr = 1;        // error : lvalue needed
const double& cdr {1}; // OK

La interpretacion de la ultima inicializacion es:

double temp = double{1};  // first create a temporar y with the right value
const double& cdr {temp}; // then use the temporar y as the initializer for cdr

Una referencia puede ser usada como parametro de una funcion:

void increment(int& aa)
{
    ++aa;
}
void f()
{
    int x = 1;
    increment(x); // x = 2
}

Las semanticas de paso de argumentos se definen como las de inicializacion, 
asi que cuando es llamado, el argumento aa de increment se convierte en otro
nombre para x. Para mantener el programa legible es usualmente mejor omitir
funciones que modifican sus argumentos. En vez de eso, se puede hacer:

int next(int p) { return p+1; }

void g()
{
    int x = 1;
    increment(x); // x = 2
    x = next(x);  // x = 3
}

La notacion increment(x) no da ninguna pista al lector de que el valor de x va 
a ser modificado, de la forma en la que x=next(x) lo hace. Consecuentemente las
referencias "planas" a argumentos solo deberian ser usadas cuando el nombre de
la funcion hace intuir que el argumento va a ser modificado.

La lvalue references solo puede referenciar a objetos modificables (no const).
Para referenciar un objeto constante se debe usar const T& ref. Tambien se 
puede hacer una referencia lvalue const a un valor modificable (no const), 
asegurando que no se pueda modificar. Se recomienda usar referencias lvalue 
const siempre que sea posible frente a usar referencias lvalue normales.


*************************************
****** 7.7.2 Rvalue References ******
*************************************

Una rvalue reference puede apuntar a una rvalue reference pero no a una lvalue
reference. 

string var {"Cambridge"};      
string f();

string& r1 {var};              // lvalue reference, bind r1 to var (an lvalue)
string& r2 {f()};              // lvalue reference, error : f() is an rvalue
string& r3 {"Princeton"};      // lvalue reference, error : cannot bind to 
                               // temporary
                               
string&& rr1 {f()};            // rvalue reference, fine: bind rr1 to rvalue (a 
                               // temporary)
string&& rr2 {var};            // rvalue reference, error : var is an lvalue
string&& rr3 {"Oxford"};       // rr3 refers to a temporary holding "Oxford"

const string cr1& {"Harvard"}; // OK: make temporary and bind to cr1

El declarador && indica rvalue reference. No se usa const en rvalue references
porque la mayoria de beneficios de usar rvalue references se encuetran en 
modificar los valor a los que apuntan.
Un const lvalue reference y un rvalue reference pueden apuntar a un rvalue. 
Pero el proposito es diferente:
 - rvalue references se usan para implementar un "destructive read" para 
 optimizar los casos en los queramos mover un valor en vez de copiarlo.
 - const lvalue references se usan para prevenir que un argumento se modifique.

El acceso a un objeto referido por una rvalue reference es el mismo que con una
lvalue reference:

string f(string&& s)
{
    if (s.size())
        s[0] = toupper(s[0]);
    return s;
}

Para hacer un perfect swap:

template<class T>
void swap(T& a, T& b) // "perfect swap" (almost)
{
    T tmp {static_cast<T&&>(a)}; // the initialization may write to a
    a = static_cast<T&&>(b);     // the assignment may write to b
    b = static_cast<T&&>(tmp);   // the assignment may write to tmp
}
El valor resultante de static_cast<T&&>(x) es un rvalue del tipo T&& para x.
Si el tipo T tiene un move constructor, lo utilizara.

El uso de static_cast en swap() es un poco verboso, asi que la libreria ofrece
una funcion move(). move(x) significa static_cast<X&&>(x). La funcion swap
quedaria asi:

template<class T>
void swap(T& a, T& b)
{
    T tmp {move(a)};
    a = move(b);
    b = move(tmp);
}

A diferencia de lo que pueda parecer move() no mueve un valor, solo produce una
referencia rvalue de un objeto. Se llama move por motivos historicos.



####################################################
###### 8 Structures, Unions, and Enumerations ######
####################################################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 8.2 Structures @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Un struct es un agregado de elementos de tipos arbritarios.
Se pueden inicializar con la notacion {}

Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    {'N','J'}, "07974"
};

Un struct se puede pasar como referencia.


*********************************
****** 8.2.1 struct Layout ******
*********************************

Un objeto de un struct contiene sus miembros en el orden en el que son 
declarados. 
El tamano de un struct no es siempre el de la suma de sus elementos. Esto se 
debe a que algunas maquinas alinean la memoria para mejorar el tiempo de acceso
Se pueden ordenar los miembros de un struct de mayor a menor tamano para 
mejorar el espacio en memoria, pero esto solo se recomienda si se nota una
mejora clara, si no es conveniente tambien dejarlos ordenados para mejor 
lectura.


********************************
****** 8.2.2 struct Names ******
********************************

El nombre de un tipo esta disponible justo despues de su declaracion. Por eso
no se puede utilizar un struct en el campo de su propia declaracion salvo que 
se declare antes:

struct No_good {
    No_good member; // error : recursive definition
};

struct List; // struct name declaration: List to be defined later

struct Link {
    Link∗ pre;
    Link∗ suc;
    List∗ member_of;
    int data;
};

struct List {
    Link∗ head;
};


******************************************
****** 8.2.3 Structures and Classes ******
******************************************

Un struct es una clase donde los miembros son publicos por defecto, asi que un
struct puede tener funciones miembros, en concreto constructores.

Los constructores se necesitan cuando se quiere reordenar argumentos, 
validarlos, modificarlos o establecer invariants.

La unica diferencia entre un struct y una class es que en un struct los 
miembros por defecto son publicos y en una class son privados. 




##########################
###### 9 Statements ######
##########################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 9.4 Selection Statements @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

*************************************
****** 9.4.2 switch Statements ******
*************************************

--- 9.4.2.1 Declarations in Cases

Cuando se declara una variable dentro de un case, no se puede pasar su 
inicializacion:

void f(int i)
{
    switch (i) {
        case 0:
            int x;     // uninitialized
            int y = 3; // error: declaration can be bypassed (explicitly 
                       // initialized)
            string s;  // error: declaration can be bypassed (implicitly 
                       // initialized)
        case 1:        
            ++x;       // error: use of uninitialized object
            ++y;
            s = "nasty!";
    }
}

Si queremos declarar una variable dentro de un bloque switch para un case 
concreto, se puede limitar su alcance con {} por ejemplo:

switch (i) {
    case 0: {
        int x = 0;
        x + 1;
        // etc;
        break;
    }
}

Nota: break; sale de bucles (for, while, etc.). return sale de funciones.




############################
###### 10 Expressions ######
############################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 10.4 Constant Expressions @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Hay dos tipos de constantes:
 - constexpr: evaluadas en tiempo de compilacion
 - const: aseguran inmutabilidad de interfaces.

Las constrexpr tienen que tener un valor inicial de tipo integral o float.

Hay varias razones para usar constant expressions:
 - 1: Named constants hacen el codigo mas facil de entender y matener
 - 2: No se puede cambiar su valor
 - 3: Se requiere constant expressions para array sizes, case labels y template
 value arguments
 - 4: Los programadores de embebidos ponen los datos inmutables en ROM.
 - 5: No hay condiciones de carrera
 - 6: Se suele obtener mejor rendimiento.
 
***************************************************
****** 10.4.2 consts in Constant Expressions ******
***************************************************

const se puede usar para expresar valores constantes:
const int x = 7;
const string s = "asdf";
const int y = sqrt(x);

A diferencia de constexpr un const puede ser inicializado por algo que no sea
una expresion constante. 

constexpr int xx = x;    // OK
constexpr string ss = s; // error : s is not a constant expression
constexpr int yy = y;    // error : sqr t(x) is not a constant expression

Usualmente constexpr es mejor opcion que const para definir constantes simples.



##################################
###### 11 Select Operations ######
##################################

@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 11.3 Lists @@@@@
@@@@@@@@@@@@@@@@@@@@@@

Ademas de usarse para inicializar variables con nombre (6.3.5.2), {}-list pueden
ser usadas como expresiones en muchos sitios. Aparecen en dos formas:
 1. Cualificadas por tipo: T{...} "crea un objeto del tipo T inicializado por
 T{...} (11.3.2)
 2. No cualificadas {...}, en las que el tipo se determina por el contexto del 
 uso (11.3.3)
 
***************************************
***** 11.3.1 Implementation Model *****
***************************************
El modelo de implementacion de {}-lists viene en tres partes:
	.Si la {}-list se usa como argumento de un constructor, la implementacion es
igual que si se usara ()-list. Los elementos de la lista no son copiados 
excepto los argumentos por valor del constructor.
	.Si la {}-list se usa para inicializar los elementos de un agregado (un 
array o clase sin constructor), cada elemento inicializa un elemento del 
agregado. Los elementos de la lista no son copiados excepto los argumentos por 
valor en el constructor del agregado.
	.Si la {}-list es usada para construir un initializer_list, cada elemento es
usado para inicializar un elemento del array interno del initializer_list. Los 
elementos son tipicamente copiados desde el initializer_list a donde sea que se
usen.

Notese que esto es un modelo general de implementacion. Un compilador puede 
aplicar optimizaciones mientras el significado se preserve.

El contenido de un {}-list (su array interno) es inmutable, lo que implica que 
normalmente su contenido es copiado y no movido.

**********************************
***** 11.3.2 Qualified Lists *****
**********************************
La idea basica de un initializer list como expresion es que si se puede 
inicializar una variable x asi:
T x{v};
entonces se puede crear un objeto con el mismo valor como una expresion usando
T{v} o new T{v}. Usar new ubica el objeto en el heap y devuelve un puntero, 
mientras que T{v} crea un objeto temporal en el scope actual.
Las reglas para construir un objeto usando un lista cualificada son las de la
inicializacion directa (16.2.6)

************************************
***** 11.3.3 Unqualified Lists *****
************************************
Una lista no cualificada es usada cuando el tipo esperado es conocido sin 
ambiguedad. Se puede usar como expresion solo en:
 . Argumento de funcion
 . Valor de retorno
 . Operando derecho de una operacion de asignacion (=, +=, etc.)
 . Un subscript
Por ejemplo:
int f(double d, Matrix& m)
{
	int v {7};         // initializer (direct initialization)
	int v2 = {7};      // initializer (copy initialization)
	int v3 = m[{2,3}]; // assume m takes value pairs as subscripts

	v = {8};     // right-hand operand of assignment
	v += {88};   // right-hand operand of assignment
	{v} = 9;     // error: not left-hand operand of assignment
	v = 7+{10};  // error: not an operand of a non-assignment operator
	f({10.0});   // function argument
	return {11}; // return value
}

La razon por la que no se permite usar { en el lado izquierdo de la asignacion
es porque podria confundirse con un bloque {}.

El tipo initializer_list<T> es usado para manejar {}-lists de longitud variable.
Su uso mas obvio es permitir initializer lists para los contenedores definidos
por el usuario, pero tambien puede ser usado directamente:

int high_value(initializer_list<int> val)
{
	int high = numeric_traits<int>lowest();
	if (val.size()==0) return high;
	
	for (auto x : val)
		if (x>high) high = x;
	
	return high;
}
int v1 = high_value({1,2,3,4,5,6,7});
int v2 = high_value({−1,2,v1,4,−9,20,v1});

Una {}-list es la manera mas simple de tratar con listas homogeneas de longitud
variable.
El tipo de la {}-list solo puede ser deducido si todos sus elementos son del 
mismo tipo.

Desafortunadamente no se puede deducir el tipo de una lista sin cualificar para 
un template argument plano:

template<typename T>
void f(T);

f({});      // error: type of initializer is unknown
f({1});     // error: an unqualified list does not match ‘‘plain T’’
f({1,2});   // error: an unqualified list does not match ‘‘plain T’’
f({1,2,3}); // error: an unqualified list does not match ‘‘plain T’’


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 11.5 Explicit Type Conversion @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

constructor usando {} provee type-safe
const_cast: para obtener acceso a escritura de algo declarado como const
static_cast : para revertir una conversion implicita bien definida
reinterpret_cast : para cambiar el significado de grandes patrones
dynamic_cast : para navegacion en jerarquias de clases chequeadas dinamicamente
c-style cast


*********************************
****** 11.5.1 Construction ******
*********************************

La ventaja de utilzar T{v} es que solo permite conversiones bien hechas

void f(int);
void f(double);
void g(int i, double d)
{
    f(i); // call f(int)
    f(double{i}); // error : {} doesn’t do int to floating conversion

    f(d);      // call f(double)
    f(int{d}); // error : {} doesn’t truncate
    f(static_cast<int>(d)); // call f(int) with a truncated value

    f(round(d));    // call f(double) with a rounded value
    f(static_cast<int>(lround(d))); // call f(int) with a rounded value
                          // if the d is overflows the int, this still truncates
}


Cuando se construye un objeto sin inicializar con el constructor {} se 
inicializa a 0 convertido a dicho valor.
Ej int{} es int = 0


********************************
****** 11.5.2 Named Casts ******
********************************

static_cast : convierte entre tipos relacionados como puntero de diferentes
    tipos o un integral a un enumeration. Realiza comprobaciones en tiempo
    de compilacion a diferencia de un C-cast.

reinterpret_cast : convierte entre tipos no relacionados.

const_cast : convierte entre tipos que difieren solo en los cualificadores
    const y volatile.
    
dynamic_cast : realiza comprobaciones en tiempo de ejecución.



##########################
###### 12 Functions ######
##########################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 12.1 Function Declarations @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

**************************************
***** 12.1.6 constexpr Functions *****
**************************************
Definir una funcion como constexpr indica que queremos usarla en expresiones
constantes si se le pasan expresiones constantes como parametros. Por ejemplo:

constexpr int fac(int n)
{
	return (n>1) ? n∗fac(n−1) : 1;
}
constexpr int f9 = fac(9); // must be evaluated at compile time

Cuando constexpr se usa en definicion de objetos significa "evalua la 
inicializacion en tiempo de compilacion". Por ejemplo: 

void f(int n)
{
	int f5 = fac(5); // may be evaluated at compile time
	int fn = fac(n); // evaluated at run time (n is a variable)
	
	constexpr int f6 = fac(6);  // must be evaluated at compile time
	// error : can’t guarantee compile-time evaluation (n is a variable)
	constexpr int fnn = fac(n);
	
	char a[fac(4)]; // OK: array bounds must be constants and fac() is constexpr
	// error : array bounds must be constants and n is a variable
	char a2[fac(n)];
	
	// ...
}

Para ser evaluada en tiempo de compilacion, una funcion debe ser simple: un solo
return, sin loops ni variables locales. Ademas una funcion constexpr es una 
funcion pura (no tiene efectos laterales).
Las reglas para un constructor constexpr son diferentes (10.4.3) y solo se 
permiten inicializacion de miembros.
Una funcion constexpr permite recursion y expresiones condicionales. Al igual 
que las funciones inline, obedecen la ODR (one definition rule), por lo que las
definiciones en las diferentes unidades de translacion debe ser identica 
(15.2.3). Se puede pensar en las funciones constexpr como una version 
restringida de las funciones inline (12.1.5).

-- 12.1.6.1 constexpr and References
Una funcion constexpr no puede tener side effects, asi que no es posible 
escribir objetos no locales. Aun asi, una funcion constexpr puede recibir 
referencias a objetos no locales mientras no escriba en ellos.

-- 12.1.6.2 Conditional Evaluation
Una expresion condicional de ramificacion que no es tomada en una funcion 
constexpr no es evaluada. Esto implica que una rama no tomada puede implicar 
evaluacion en tiempo de ejecucion. Por ejemplo:

constexpr int check(int i)
{
	return (low<=i && i<high) ? i : throw out_of_range();
}
constexpr int low = 0;
constexpr int high = 99;
// ...
constexpr int val = check(f(x,y,z));

**********************************
***** 12.1.8 Local Variables *****
**********************************

Una variable de alcance local es inicializada cuando un hilo de ejecucion 
alcanza su definicion. Cada vez que se llama a esa funcion se tiene una copia de
la variable a no ser que sea declarada static. 

Una variable definida como static dentro de una funcion asegura preservar su
valor entre las multiples llamadas a la funcion, ademas de mantener un alcance
local y no poder ser accedidad por otras funciones, evitando tambien hacerla 
const. Esto es muy util cuando se trabaja con ids, por ejemplo: 

int generateId() {
    static int id {0};
    return id++;
} /* Cada vez devuelve el siguiente id sin necesidad de tener una variable
     global */


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 12.2 Argument Passing @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Los argumentos salvo que se pasen por referencia, se pasan por copia.

**************************************
***** 12.2.1 Reference Arguments *****
**************************************

Las referencias pasadas como argumento que no se vayan a modificar se deben 
pasar como const.
Las semanticas del paso de argumento son diferentes a las de asignacion. 
Siguiendo las reglas de inicializacion por referencia, un literal, constante o
argumento que requiera una conversion puede ser pasado como const T&, pero no 
como un T&.

Thumb rules del paso de argumentos por referencia:
 - usar paso por valor para objetos pequenos
 - usar paso por referencia constante para objetos grandes que no se modifiquen
 - devolver un resultado como un return value en vez de modificar un objeto a
 traves de un argumento.
 - usar rvalue references para implementar move y forwarding
 - pasar un puntero si un "no-object" es una alternativa valida
 - usar paso por referencia solo en caso necesario



###################################
###### 13 Exception Handling ######
###################################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 13.1 Error Handling @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Este capitulo se centra en como y cuando deberian gestionarse las excepciones
para diferentes tipos de programas.

*****************************
***** 13.1.1 Exceptions *****
*****************************

Cuando se produce una excepcion hay dos elementos: el calling component, que 
debe utilizar un bloque try catch, y el called component que debe lanzar la 
excepcion con un throw.

Una exception es un objeto. Puede ser cualquier tipo de objeto pero es 
recomendable que sea un objeto creado para este proposito.
Una exception puede contener un string con informacion sobre el error producido


*********************************************
***** 13.1.2 Traditional Error Handling *****
*********************************************

Para problemas que no pueden ser manejados localmente (por ejemplo out-of-
range) se puede usar el traditional error handling. Este metodo tiene varias
aproximaciones, aunque cada una tiene problemas:
 - Terminar el programa con exit()
 - devolver un error value (con un int por ejemplo)
 - devolver un valor legal pero dejar el programa en estado de error
 - llamar a una funcion error_handler()


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 13.3 Resource Management @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Una forma de manejar excepciones al tratar con ficheros es:

void use_file(const char∗ fn) // clumsy code
{
    FILE∗ f = fopen(fn,"r");
    try {
        // ... use f ...
    }
    catch (...) { // catch every possible exception
        fclose(f);
        throw;
    }
    fclose(f);
}

Esta forma es efectiva pero verbosa y potencialmente expensiva.
Otra forma de gestionarlo es utilizando una clase que maneje la adquisicion y 
liberacion de recursos:

class File_ptr {
    FILE∗ p;
public:
    File_ptr(const char∗ n, const char∗ a) // open file n
        : p{fopen(n,a)}
    {
        if (p==nullptr) throw runtime_error{"File_ptr: Can't open file"};
    }
    
    File_ptr(const string& n, const char∗ a) // open file n
        :File_ptr{n.c_str(),a}
    {}
    
    explicit File_ptr(FILE∗ pp) // assume ownership of pp
        :p{pp}
    {
        if (p==nullptr) throw runtime_error("File_ptr: nullptr"};
    }
    
    // ... suitable move and copy operations ...
    
    ˜File_ptr() { fclose(p); }
    
    operator FILE∗() { return p; }
};

void use_file(const char∗ fn)
{
    File_ptr f(fn,"r");
    // ... use f ...
}

Se puede construir un File_ptr con un FILE* o con los argumentos para fopen() y
de cualquier forma  el destructor cerrar el fichero al salir del scope. Esto 
hace que no tengamos que utilizar try catch para usar el fichero porque el 
destructor es llamando tanto si se abre correctamente como si no lo hace. 
Esta forma de manejar recursos utilizando objetos locales se denomia RAII.
Estas "handle class" tambien se denominan RAII class.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 13.4 Enforcing Invariants @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Hay dos enfoques cuando un precondicion no es cumplida:
 - No hacerlo. Es trabajo de quien llama a la funcion conocer las 
 precondiciones y por tanto se deja que ocurra algo malo con el programa.
 - Terminar el programa completamente.

Para comprobar las invariantes se utiliza assert, que tienen unas necesidades:
 - Elegir entre asserts en tiempo de compilacion y ejecucion
 - Para las run-time asserts hay que elegir throw, terminate o ignore.
 - Algunas run-time asserts no deberian ser comprobadas salvo que se de una 
 condicion logica (pe. flag de debug)
 - Las asserts no deberian ser complicadas o verbosas de escribir.

El standard ofrece dos mecanismos:
 - en <cassert> se provee la macro assert(A) que comprueba la asercion A en run
 time si y solo si la macro NDEBUG ("not debugging") no esta definida. si la 
 asercion falla el compilador escribe un mensaje de error con la asercion 
 fallida, el nombre del source file y la linea.
 - el lenguaje proporciona static_assert(A,message) que comprueba 
 incondicionalmente la asercion A en tiempo de compilacion. Si falla, el 
 compilador escribe el message.

Aunque assert() y static_assert() no son suficientes, se pueden usar en codigo
ordinario para comprobaciones.

Nota: assert de cassert no lanza excepciones porque es de C y C no tiene 
excepciones. Sale del programa con un exit()


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 13.5 Throwing and Catching Exceptions @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

**************************************
***** 13.5.1 Throwing Exceptions *****
**************************************

Se pueden lanzar excepciones de cualquier tipo que pueda ser copiado o movido.
Para lanzar la excepcion hay que escribir throw objeto;

To-do: stack unwinding -> ver apuntesVarios

-- 13.5.1.1 noexcept Functions
Una funcion que se declara como noexcept indica que no va a lanzar una 
excepcion. Este aviso es principalmente para el programador y para el 
compilador, que aplica optimizaciones. Aun asi, el compilador confia en el 
noexcept y no comprueba si su contenido lanza o no excepciones, lo que puede 
llevar a comportamiento indefinido.

**************************************
***** 13.5.2 Catching Exceptions *****
**************************************

void f()
{
    try {
        throw E{};
    }
    catch(H) {
        // when do we get here?
    }
}






##########################################
###### 15 Source Files and Programs ######
##########################################

@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 15.2 Linkage @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@

Internal linkage: solo puede ser accedido en el mismo fichero.
External linkage: puede ser accedido desde otros ficheros.

static int x1 = 1;   // internal linkage: not accessible from other translation
                     // units
const char x2 = 'a'; // internal linkage: not accessible from other translation 
                     // units

int x1 = 1;                 // external linkage: accessible from other 
                            // translation units
extern const char x2 = 'a'; // external linkage: accessible from other 
                            // translation units

Las variables const se pueden convertir en globales utilizando la palabra 
extern.
Para utilizar una variable global:
    -fichero que la comparte: se define como global (ej. int x = 2;)
    -fichero que la usa: se indica que se va a usar una variable externa (ej. 
    extern int x;)

Las variables globales constexpr nunca pueden tener una vinculacion externa
porque no pueden tener una declaracion anticipada.

Las variables locales estan fuera del alcance del linker y se considera que
no tienen linkage.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 15.3 Using Header Files @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

*********************************
***** 15.3.3 Include Guards *****
*********************************

Recomienda usar el estilo #ifndef en vez de pragmas


@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 15.4 Programs @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@

**************************************
***** 15.4.3 Program Termination *****
**************************************

Un programa puede terminar por varios motivos:
 - returning from main()
 - calling exit()
 - calling abort()
 - throwing an uncaught exception
 - violating noexcept
 - calling quick_exit()
 
Si el programa termina siendo llamado por la funcion de la libreria standard
exit(), llama a los destructores de los objetos creados. Si se usa a abort()
no llama a los destructores.

La funcion de la libreria standard atexit(func) permite llamar a func cuando se
sale del programa.


****************************************
***** 16.2.6 explicit Constructors *****
****************************************
Un constructor declarado como explicit no permite que sus parametros sean 
convertidos implicitamente al tipo requerido. Por ejemplo si nuestro constructor
necesita un int y esta como explicit, pasarle un float produciria un error.

Una inicializacion con = es considerada una inicializacion de copia. Omitir el =
hace que la inicializacion sea explicita. La inicializacion explicita es 
conocida como inicializacion directa. 
Sugiere que un constructor con un unico argumento se declare como explicit salvo
que haya una buena razon para no hacerlo.

Explicit tambien puede ser util para constructores vacios o con varios 
argumentos:
struct X {
	explicit X();
	explicit X(int,int);
};

X x1 = {};    // error : implicit
X x2 = {1,2}; // error : implicit

X x3 {};      // OK: explicit
X x4 {1,2};   // OK: explicit

int f(X);

int i1 = f({});    // error : implicit
int i2 = f({1,2}); // error : implicit

int i3 = f(X{});    // OK: explicit
int i4 = f(X{1,2}); // OK: explicit


**************************************
****** 16.2.12 [static] Members ******
**************************************
Una funcion o miembro estaticos solo se inicializan una vez antes de crear la
clase, y son comunes a todos las instancias de la clase, que en vez de crear 
una copia de la funcion o miembro, usan el estatico global.


######################################################
###### 17 Construction, Cleanup, Copy, and Move ######
######################################################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 17.2 Constructors and Destructors @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

**********************************************
***** 17.2.1 Constructors and Invariants *****
**********************************************

En los constructores es interesante hacer invariantes, que son condiciones que 
se deben comprobar antes de crear el objeto para lanzar una excepcion antes de 
crear un objeto en estado invalido. Por ejemplo:

Vector::Vector(int s)
{
if (s<0) throw Bad_size{s};
sz = s;
elem = new double[s];
}

********************************************
***** 17.2.2 Destructors and Resources *****
********************************************

Vector∗ f(int s)
{
    Vector v1(s);
    // ...
    return new Vector(s+s);
}

void g(int ss)
{
    Vector∗ p = f(ss);
    // ...
    delete p;
}

Aqui, el Vector v1 es destruido al salir de f(). El Vector creado usando new es
destruido por la llamada a delete.
Si el constructor tiene algun problema en adquirir suficiente memoria lanza una
excepcion std::bad_alloc,

Este estilo de manejo de recursos constructor/destructor se denomina RAII 
(Resource Acquisition Is Initialization)


**********************************************
***** 17.2.3 Base and Member Destructors *****
**********************************************

Los constructores y destructores interactuan correctamente con la jerarquia de 
clases desde abajo hacia arriba:
Constructor:
 - 1: Invoca el constructor de la clase base
 - 2: invoca los constructores miembro
 - 3: ejecuta su propio cuerpo
Destructor:
 - 1: ejecuta su propio cuerpo
 - 2: invoca el destructor de los miembros
 - 3: invoca el destructor de la clase base

En particular una virtual base es construida antes que cualquier base que 
deberia usarla y destruida antes que cualquiera de esas bases. Este orden
asegura que una base o un miembro no es usado antes de ser inicializado ni 
despues de ser destruido.


*******************************************************
***** 17.2.4 Calling Constructors and Destructors *****
*******************************************************

Un destructor es invocado implicitamente al salir de un scope o por delete.
Es tipicamente innecesario llamar a un destructor explicitamente, esto puede 
llevar a errores.

Si queremos hacer que un destructor no sea llamado implicitamente y solo sea 
llamado por delete, se tiene que poner el destructor ~Clase() dentro de los
miembros privados de la clase.


**************************************
***** 17.2.5 virtual Destructors *****
**************************************

Un destructor puede ser declarado virtual y usualmente deberia hacerse para 
clases con funciones virtuales.
La razon por la que necesitamos destructores virtuales es porque un objeto 
manipulado a traves de una interface proveida por una clase es usualmente 
eliminada a traves de esa interfaz.

class Shape {
public:
    // ...
    virtual void draw() = 0;
    virtual ˜Shape();
};

class Circle {
public:
    // ...
    void draw();
    ˜Circle();   // overrides ~Shape()
    // ...
};

void user(Shape∗ p)
{
    p−>draw(); // invoke the appropriate draw()
    // ...
    delete p;  // invoke the appropriate destructor
};

Si el destructor no fuera virtual en Shape, al eliminar p, se eliminaria solo 
los recursos de Shape y habria un leak de los recursos de la parte de Circle.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 17.3 Class Object Initialization @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

******************************************************
***** 17.3.1 Initialization Without Constructors *****
******************************************************

struct Work {
    string author;
    string name;
    int year;
};

Cuando no se define un constructor pero se requieren argumentos se puede dejar
la clase sin inicializar:

Work alpha;
void f()
{
    Work beta;
    //...
}

Para los objetos alocados estaticamente las reglas son las mismas que si se 
hubiese usado {}. Asi que el valor de alpha es {"","",0}. Pero para variables
locales y free-store objects el incializador por defecto solo se llama para 
miembros de un class type y los miembros de built-in types se quedan sin 
inicializar. Asi que el valor de beta es {"","",unknown}. El motivo de esto es
para mejorar el rendimiento en casos criticos.
Salvo que se quiera dejar sin inicializar por un motivo de rendimiento, es 
recomendable inicializar con {} para evitar errores.

Segun las cpp core guidelines es recomendable usar {} siempre que sea posible.


****************************************************
***** 17.3.2 Initialization Using Constructors *****
****************************************************

La inicializacion {} es universal y se puede usar en cualquier sitio, a 
diferencia de = y () que no se pueden usar en un constructor, por ejemplo.
La inicializacion uniforme {} no permite estrechamiento (narrowing), por eso es
recomendable para inicializar parametros, ya que realiza comprobaciones de tipo 

-- 17.3.2.1 Initialization by Constructors

// no constructor
struct S1 {
    int a,b;
};

// constructor
struct S2 {
    int a,b;
    S2(int a = 0, int b = 0) : a(aa), b(bb) {}
};

S1 x11(1,2);  // error : no constructor
S1 x12 {1,2}; // OK: memberwise initialization

S1 x13(1);    // error : no constructor
S1 x14 {1};   // OK: x14.b becomes 0

S2 x21(1,2);  // OK: use constructor
S2 x22 {1,2}; // OK: use constructor

S2 x23(1);    // OK: use constructor and one default argument
S2 x24 {1};   // OK: use constructor and one default argument


************************************************
***** 17.3.4 Initializer-List Constructors *****
************************************************
Un constructor que tiene un solo argumento del tipo std::initializer_list es 
llamado initializer-list constructor y usa una lista {} como valor de 
inicializacion.

El mecanismo para aceptar una {}-list es una funcion (usualmente un constructor)
que toma un argumento del tipo std::initializer_list<T> por ejemplo:

void f(initializer_list<int>);

f({1,2});
f({23,345,4567,56789});
f({});     // the empty list

f{1,2};    // error: function call () missing

-- 17.3.4.1 initializer_list Constructor Disambiguation

Cuando hay sobrecarga de constructores, los constructores por defecto y los
constructores initializer-list tienen prioridad para ser seleccionados.
El orden de preferencia es:
 - 1: default constructor
 - 2: initializer-list constructor
 - 3: ordinary constructor
 
-- 17.3.4.2 Use of initializer_lists
Desafortunadamente initializer_list no permite subscripting (operador []).
Una initializer_list se tiene que pasar por valor, porque las overload 
resolution rules (12.3) asi lo requieren, y no crea mucho overhead.
Los elementos de un initializer_list son inmutables, por lo que no se pueden 
realizar operaciones de movimiento sobre ellos.

Un contenedor puede implementar su initializer-list constructor asi:

template<class E>
class Vector {
public:
	Vector(std::initializer_list<E> s); // initializer-list constructor
	// ...
private:
	int sz;
	E∗ elem;
};

template<class E>
Vector::Vector(std::initializer_list<E> s)
	:sz{s.size()}  // set vector size
{
	reserve(sz);   // get the right amount of space
	// initialize elements in elem[0:s.size())
	uninitialized_copy(s.begin(), s.end(), elem); 
}


-- 17.3.4.3 Direct and Copy Initialization
La distincion entre inicializacion directa y de copia (16.2.6) se mantiene para 
la inicializacion {}. Para un contenedor esto implica que la distincion se 
aplica para el contenedor y para sus elementos:
 .El initializer-list constructor del constenedor puede ser explicito o no
 .El constructor del tipo del elemento de la initializer list puede ser explicit
 o no.
En un vector<vector<double>> se puede ver la diferencia entre inicializacion 
directa vs copia:

vector<vector<double>> vs = {
	{10,11,12,13,14}, // OK: vector of five elements
	{10},             // OK: vector of one element
	10,               // error : vector<double>(int) is explicit
	
	vector<double>{10,11,12,13}, // OK: vector of five elements
	vector<double>{10},          // OK: vector of one element with value 10.0
	vector<double>(10),          // OK: vector of 10 elements with value 0.0
};



@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 17.4 Member and Base Initialization @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

****************************************
***** 17.4.1 Member Initialization *****
****************************************

Los miembros de una clase que se inicializan con una intializer list en el 
constructor son inicializados antes que el cuerpo del constructor sea llamado

class Club {
    string name;
    vector<string> members;
    vector<string> officers;
    Date founded;
    // ...
    Club(const string& n, Date fd);
};

Club::Club(const string& n, Date fd)
    : name{n}, members{}, officers{}, founded{fd}
{
    // ...
}

La lista de inicializacion deberia tener el mismo orden que la declaracion de 
los argumentos.

Club::Club(const string& n, Date fd)
    : name{n}, founded{fd}
{
    // ...
}

Este constructor es equivalente al anterior, pero dos parametros se inicializan
implicitamente. Se recomienda ser explicito con la inicializacion porque dejar
que algunos miembros se inicializen implicitamente puede dar lugar a problemas
(ver 17.3.1)

Un constructor que hereda de una clase no puede inicializar los miembros de una
clase madre.

struct B { B(int); /* ... */};
struct BB : B { /* ... */ };
struct BBB : BB {
    BBB(int i) : B(i) { }; // error : trying to initialize base’s base
    // ...
};

-- 17.4.1.1 Member Initialization and Assignment

La inicializacion de miembros es esencial para tipos donde se quiera 
diferenciar entre inicializacion y asignacion.

Para miembros const se puede elegir entre utilizar inicializacion por 
initializer o por asignacion. Normalmente es mas recomendable usar initializer
por motivos de eficiencia.

class X {
    const int i;
    Club cl;
    Club& rc;
    // ...
    X(int ii, const string& n, Date d, Club& c) : i{ii}, cl{n,d}, rc{c} { }
};

************************************
***** 17.4.2 Base Initializers *****
************************************

Si una base requiere un inicializador, debe proveerse en el constructor. Esto
se puede hacer explicitamente o implicitamente:

class B1 { B1(); }; // has default constructor
class B2 { B2(int); } // no default constructor

struct D1 : B1, B2 {
	D1(int i) :B1{}, B2{i} {}
};

struct D2 : B1, B2 {
	D2(int i) :B2{i} {} // B1{} is used implicitly
};

struct D1 : B1, B2 {
D1(int i) { }           // error : B2 requires an int initializer
};

******************************************
***** 17.4.3 Delegating Constructors *****
******************************************

Si queremos dos constructores que hagan lo mismo, se puede crear un init() para
evitar repetirse. Por ejemplo este codigo:
class X {
	int a;
	validate(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
	public:
	X(int x) { validate(x); }
	X() { validate(42); }
	X(string s) { int x = to<int>(s); validate(x); }

};
Puede escribirse mejor asi:
class X {
	int a;
	public:
	X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
	X() :X{42} { }
	X(string s) :X{to<int>(s)} { }
};

El constructor X(): X{42} {} es un delegating constructor. Lo que no se puede 
hacer es delegar e inicializar explicitamente un miembro en el mismo constructor

class X {
	int a;
	public:
	X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
	X() :X{42}, a{56} { } // error
};

Es importante llamar al constructor delegado en la initializer list, y no 
hacerlo en el cuerpo, ya que esto crea un objeto temporal y puede dar error:
X() { X{42}; } // likely error

****************************************
***** 17.4.4 In-Class Initializers *****
****************************************

Dentro de una clase se pueden inicializar miembros no estaticos con = y con {}:

class A {
public:
int a {7};
int b = 77;
};

Por defecto un constructor usara esta inicializacion, por lo que lo anterior es 
equivalente a:

class A {
public:
int a;
int b;
A() : a{7}, b{77} {}
};

Para evitar escribir en constructores mas complicados, donde en varios de ellos
se inicializan los mismos miembros, se puede simplificar de la siguiente manera:

class A {
public:
	A() :a{7}, b{5}, algorithm{"MD5"}, state{"Constructor run"} {}
	A(int a_val) :a{a_val}, b{5}, algorithm{"MD5"}, state{"Constructor run"} {}
	A(D d) :a{7}, b{g(d)}, algorithm{"MD5"}, state{"Constructor run"} {}

private:
int a, b;
HashFunction algorithm;
string state;
};

Se simplifica asi:

class A {
public:
	A() :a{7}, b{5} {}
	A(int a_val) :a{a_val}, b{5} {}
	A(D d) :a{7}, b{g(d)} {}
private:
	int a, b;
	HashFunction algorithm {"MD5"};
	string state {"Constructor run"};
};

Si un miembro se inializa por el inicializador in-class y por el constructor, 
prevalece el del constructor, por lo que el ejemplo se puede simplificar mas:

class A {
public:
	A() {}
	A(int a_val) :a{a_val} {}
	A(D d) :b{g(d)} {}
private:
	int a {7};
	int b {5};
	HashFunction algorithm {"MD5"};
	string state {"Constructor run"};
};

***********************************************
***** 17.4.5 static Member Initialization *****
***********************************************

Los miembros estaticos se alocan estaticamente en vez de ser parte de la clase,
pero tambien se pueden inicializar dentro de la clase en algunos casos:

class Curious {
	public:
	static const int c1 = 7;	// OK
	static int c2 = 11;	// error : not const
	const int c3 = 13; // OK, but not static (§17.4.4)
	static const int c4 = sqrt(9); // error : in-class initializer not constant
	// error : in-class not integral (use constexpr rather than const)
	static const float c5 = 7.0; 
};

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 17.5 Copy and Move @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Para transferir el valor de x a y se puede hacer de dos formas:
- copiar: despues de la operacion x=y, x e y tendran el valor previo de y
- mover: deja x con el valor previo de y, e y con un "moved-from state". Este 
"moved-from state" en contenedores es "empty".

Tipicamente un move es mas eficiente que un copy, y copy puede lanzar 
excepciones porque puede necesitar reservar memoria, mientras que move no. 
Al hacer una operacion de movimiento, hay que dejar el objeto fuente en un 
estado valido pero inespecificado, porque eventualmente sera destruido, y el 
destructor debe destruir un objeto en un estado valido. 

***********************
***** 17.5.1 Copy *****
***********************
La copia en una clase X esta definida por dos operaciones:
-Copy constructor: X(const X&)
-Copy assignment: X& operator=(const X&) 
El tipo devuelto por el copy assigment puede ser const X&, pero el autor 
recomienda devolver tipos convencionales para no causar confusion.	

La diferencia entre copy assigment y copy constructor es que el constructor 
inicializa la memoria sin inicializar, mientras que el asigment debe tratar 
correctamente con un objeto que ya ha sido construido y puede poseer recursos.

En el ejemplo del libro, el copy assigment operator tiene la propiedad de que si
la copia de un elemento lanza una excepcion, puede dejar el objeto en un 
estado intermedio entre su estado anterior y el actual, por lo que provee 
garantia basica, pero no fuerte garantia. Si esto no es aceptable, se puede 
evitar por la tecnica de hacer primero una copia y luego swap: 

Matrix& Matrix::operator=(const Matrix& m) // copy assignment
{
Matrix tmp {m};  // make a copy
swap(tmp,∗this); // swap tmp’s representation with *this’s
return ∗this;
}

Es interesante comprobar autoasignacion m=m en caso de que nuestra clase 
queremos que lo soporte o no. 

-- 17.5.1.1 Beware of Default Constructors
En el caso de que se nos olvide un miembro de la clase en el constructor de 
copia, se inicializa a su valor por defecto , lo que puede ser un error. Por eso
en clases complejas es conveniente dejar el constructor de copia por defecto.

-- 17.5.1.2 Copy of Bases
Al copiar un objeto derivado de una clase, se debe llamar a los constructores
de copia hasta la base:

struct B1 {
B1();
B1(const B1&);
};

struct B2 {
B2(int);
B2(const B2&);
};

struct D : B1, B2 {
D(int i) :B1{}, B2{i}, m1{}, m2{2∗i} {}
D(const D& a) :B1{a}, B2{a}, m1{a.m1}, m2{a.m2} {}
B1 m1;
B2 m2;
};

D d {1}; // construct with int argument
D dd {d}; // copy construct

-- 17.5.1.3 The Meaning of Copy
Para que una operacion de copia x=y sea valida, debe cumplir dos criterios:
- equivalencia: despues de x=y, se debe cumplir x==y y f(x)==f(y) para cualquier
funcion f()
- independencia: despues de x=y, f(x) no debe cambiar el valor de y ni f(y) el 
de x.

Sobre el requisito de equivalencia, no es necesario copiar todos los miembros 
de una funcion, solo los necesarios para que se cumpla x==y. Por ejemplo 
iteradores, o valores temporales no son necesarios.

Sobre el requisito de la independencia, el principal problema suele ser copiar
punteros que terminan implicando que ambos objetos apunten al mismo sitio. En 
alguna ocasion esto puede ser algo intencionado, pero se debe usar punteros 
compartidos.

-- 17.5.1.4 Slicing
Un puntero a una clase derivada implicitamente se convierte a un puntero a su 
clase base publica, lo que puede producir slicing:

struct Base {
	int b;
	Base(const Base&);
};
struct Derived : Base {
	int d;
	Derived(const Derived&);
};

void naive(Base∗ p)
{
B b2 = ∗p;  // may slice: invokes Base::Base(const Base&)
}

void user()
{
Derived d;
naive(&d);
Base bb = d; // slices: invokes Base::Base(const Base&), not 
             // Derived::Derived(const Derived&)
}

Si no se quiere permitir esto, se puede prevenir de dos formas:
1. Prohibir copiar la clase base estableciendo en delete sus operaciones de 
copia
2. Prevenir conversion de un puntero a clase derivada a un puntero a clase base,
haciendo la clase base una base private o protected (§20.5).

1 Dara error en las inicializaciones de bb y b2, 2 dara error en la llamada a 
naive() e inicializacion de bb.

***********************
***** 17.5.2 Move *****
***********************
Los move constructors y assigments toman non-const r-value references como 
argumentos, y se deben encargar de que el r-value queda en un estado en el que
el destructor pueda tratar con el facilmente.

Los compiladores generalmente saben cuando usar move en vez de copy, normalmente
usan move cuando la siguiente accion destruye el objeto, por ejemplo un return
value. Aun asi es conveniente indicarselo usando un rvalue reference:

template<class T>
void swap(T& a, T& b) {// "perfect swap" (almost)
T tmp = std::move(a);
a = std::move(b);
b = std::move(tmp);
}

move() no mueve nada, unicamente hace un cast a rvalue reference para que se
puedan realizar operaciones de move sobre ese objeto.

Los contenedores de la libreria estandar, y muchos tipos, tienen operaciones de
movimiento. Algunas operaciones que insertan elementos en los contenedores 
tambien tienen versiones de movimiento como insert() y push_back().

************************************
***** 17.6.4 deleted Functions *****
************************************
Se pueden eliminar funciones para que no sean usadas implicitamente o 
explicitamente. Se suele hacer con funciones que son creadas por defecto como
los constructores de copia en clases abstractas para evitar el slicing.

Tambien se puede usar para eliminar especializaciones de templates:
template<class T>
T∗ clone(T∗ p) // return copy of *p
{
return new T{∗p};
};
Foo∗ clone(Foo∗) = delete; // dont try to clone a Foo

Se puede usar para bloquear conversiones no deseadas:
struct Z {
	Z(double);
	Z(int) = delete;
};

Un uso tambien es controlar donde una clase puede ser alocada:

class Not_on_stack {
	~Not_on_stack() = delete;
};
class Not_on_free_store {
	void∗ operator new(size_t) = delete;
};

void f()
{
	Not_on_stack v1;      // error : can’t destroy
	Not_on_free_store v2; // OK
	
	Not_on_stack∗ p1 = new Not_on_stack;           // OK
	Not_on_free_store∗ p2 = new Not_on_free_store; // error : can’t allocate
}
De todas formas el Not_on_stack nunca puede ser destruido. La tecnica 
alternativa es hacer el destructor privado (17.2.2).



##############################
##### 20 Derived Clasess #####
##############################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 20.2 Derived Classes @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

En una herencia (por ejemplo class Manager : public Employee), al crear una 
instancia de Manager, no se genera overhead en memoria, unicamente ocupa los 
bytes de un Employee + los bytes de un Manager.
Normalmente los bytes del Employee iran al comienzo del objeto, y a 
continuacion los de Manager.  

***********************************
***** 20.2.1 Member Functions *****
***********************************

Unicamente se heredan los miembros publicos y protegidos

***********************************************
***** 20.2.2 Constructors and Destructors *****
***********************************************

Los objetos se construyen desde la clase base hasta la ultima derivada, y se
destruyen desde la ultima derivada hasta la base.
Cada clase puede inicializar sus miembros y bases, pero no directamente los 
miembros y bases de sus bases.
Tipicamente, los destructores de la jerarquia necesitan ser virtuales (17.5.1.4)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 20.3 Class Hierarchies @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

******************************
***** 20.3.1 Type Fields *****
******************************

Para usar clases derivadas se debe resolver el siguiente problema: dado un 
puntero de Base*, a que tipo derivado realmente apunta ? Hay cuatro soluciones:
1. Asegurarse de que solo objetos de un solo tipo sean apuntados (ch. 23)
2. Colocar un type field en la clase base para que las funciones lo inspeccionen
3. Usar dynamic_cast
4. Usar funciones virtuales

La solucion 1 requiere mucho conocimiento de tipos. La solucion 3 es una 
variante soportada por el lenguaje de la solucion 2. La solucion 4 es una 
special type-safe variation de la solucion 2. La combinacion de las soluciones
1 y 4 es particularmente interesante y potente, y en la mayoria de casos generan
codigo mas limpio que las soluciones 2 y 3. 

Primero veremos la solucion de un simple type-field para entender porque debe
ser evitada:

struct Employee {
	enum Empl_type { man, empl };
	Empl_type type;
	Employee() : type{empl} { }
	string first_name, family_name;
	char middle_initial;
	Date hiring_date;
	short department;
};
struct Manager : public Employee {
	Manager() { type = man; }
	list<Employee∗> group; // people managed
	short level;
};

Se podria crear una funcion externa para imprimir informacion en funcion de si
es Employee o Manager, y funcionaria bien, pero el problema es cuando se crean
mas clases derivadas, y hay que comprobar todas las posibilidades del enum, 
dando lugar a clases y funciones dificiles de mantener.

************************************
***** 20.3.2 Virtual Functions *****
************************************
La palabra virtual indica que un metodo puede actuar como interfaz para dicha 
funcion. Esto significa que si la funcion es sobreescrita en una clase derivada,
esta debe tener la misma firma y tipo de retorno. Ademas, obliga a definirla en
la clase base o hacerla virtual pura para obligar a las clases derivadas a 
definirla.
Al sobreescribir una funcion en una clase derivada, siempre se va a llamar a la 
funcion en la clase donde mejor corresponda ser llamada. Esto funciona gracias 
al virtual function call mechanism, y se denomina polimorfismo.
Para acceder al runtime polymorphic behavior, la funcion llamada debe ser 
virtual, y el objeto debe ser una referencia o puntero. Cuando se manipula un 
objeto directamente, el tipo del objeto es conocido en tiempo de compilacion y
por eso no se necesita este mecanismo. 
Una clase que sobrescribe una funcion virtual se convierte en una clase virtual.
En la clase derivada no hace falta poner la keyword virtual (el autor no lo 
recomienda).

Para implementar polimorfismo, el compilador debe almacenar informacion de cada
objeto de la clase polimorfica. En una implementacion tipica, el compilador
convierte el nombre de una funcion virtual en un indice en una tabla de punteros
a funciones. Esta tabla se denomina virtual function table o vtbl. Cada clase
con funciones virtuales tiene su propia vtbl indentificando sus funciones. 
Representacion grafica en pag. 588. Las funciones en la vtbl permiten al objeto
ser usado correctamente incluso cuando el tamaño del objeto y el layout de sus
datos sea desconocido para el llamador. La implementacion del llamador solo 
necesita cononcer la ubicacion de la vtbl en un Employee y el indice usado para
cada funcion virtual. Este mecanismo puede ser casi igual de eficiente que 
llamar a una funcion normal. El overhead de espacio es un puntero en cada 
objeto mas una vtbl por cada clase

Nota Gabriel: en el momento en que una funcion es virtual y durante el programa
se necesita usar polimorfismo, el compilador crea una vtable en cada clase 
virtual de la siguiente forma: al comienzo de la clase hay un puntero que apunta
a la direccion de la vtable, y en la vtable hay punteros a cada funcion de la
clase que haya heredado o sobreescrita de forma que si ha heredado la funcion A
de su padre, habra un puntero a la implementacion de A del padre, si ha 
sobreescrito la funcion B de su abuelo, habra un puntero a su propia funcion B, 
etc. A su vez, el padre, abuelo, etc, tendran vtables con sus correspondientes
punteros. Cuando se accede al objeto, se mira su puntero virtual (ubicado al 
comienzo de la clase) y por ello, independientemente de la encapsulacion que 
tenga, se va a saber exactamente que metodos tiene que usar. Esto se puede ver
en godbolt con -O0

*****************************************
***** 20.3.3 Explicit Qualification *****
*****************************************

Los diferentes cualificadores en herencia abstracta son:
- virtual: la funcion puede ser sobreescrita
- =0: la funcion debe ser virtual y debe ser sobreescrita
- override: la funcion tiene intencion de sobreescribir una funcion virtual en 
la clase base
- final: la funcion no tiene intencion de ser sobreescrita  

En la ausencia de cualquiera de estos cualificadores, una clase es virtual solo
si sobreescribe una funcion virtual de una clase base.
Ademas, estos cualificadores permiten al compilador comprobar que el codigo es
correcto.

-- 20.3.4.1 override
En una jerarquia de clases con muchas funciones virtuales se recomienda usar
virtual solo para introducir la funcion, y override en todas las funciones que
quieran sobreescribirla.

-- 20.3.4.2 final
final se usa para hacer que una funcion virtual deje de serlo despues de ser
sobrescrita, es decir, corta la herencia de esa funcion haciendo que la clase
pueda ser no virtual si nadie mas va a heredar de ella.
Si se pone final en la declaracion de la clase, todas las funciones virtuales
de la clase se convierten en final. Por ejemplo: 
class For_statement final : public Node
Esto se podria ver como una optimizacion de rendimiento (convertir a no virtual
clases virtuales cuando ya nadie va a heredar de ellas), pero se recomienda que
se use mas como semantica que como optimizacion.

*************************************
***** 20.3.5 using Base Members *****
*************************************


##########################
###### 23 Templates ######
##########################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 23.1 Introduction and Overview @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Las templates dan soporte para la programacion generica en forma de programacion
usando tipos como parametros.
La composicion ofrecida por las templates es type-safe (ningun objeto puede ser
implicitamente usado de forma que desacuerde su definicion), pero 
desafortunadamente los requisitos de una plantilla sobre sus argumentos no 
pueden ser simple y directamente fijados en el codigo (24.3). Todas las 
abstracciones de la liberia estandar (string, list, map, etc) asi como sus 
operaciones, estan hechas con templates.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 23.2 A Simple String Template @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
El prefijo "template<typename C>" especifica que la template esta siendo 
declarada y que el argumento C representa un tipo de datos y sera usado en la
declaracion. Despues de esta linea, C se usa como cualquier otro tipo y su scope
se extiende hasta el final de la declaracion de la template. De forma 
equivalente se puede usar el prefijo "template<class C>". 
C representa el nombre de una clase y puede ser cualquier clase. C++ no tiene un
mecanismo para indicar un subconjunto de clases y C puede referirse a cualquier 
clase. Aun asi hay tecnicas para simular esto. 

**************************************
***** 23.2.1 Defining a Template *****
**************************************
Las templates crean sus especializaciones necesarias en tiempo de compilacion
unicamente si son usadas, por lo que solo crean el codigo necesario que se usara
en el programa y ademas lo hacen en tiempo de compilacion.
El autor recomienda que al crear una class template, primero se cree una 
especializacion (por ejemplo crear string antes de string<C>) y diseñarla entera
antes de transformarla en template. Indica que esto ayuda a gestionar muchos 
problemas de diseño.

Los miembros de una template class son en si mismos templates parametrizadas por
los template parameters de su clase. Cuando estos miembros son declarados fuera
de la clase, debe indicarse explicitamente que son plantillas:

template<typename C>
String<C>::String() // String<C>’s constructor
	:sz{0}, ptr{ch}
{
	ch[0] = {}; // terminating 0 of the appropriate character type
}

template<typename C>
String& String<C>::operator+=(C c)
{
	// ... add c to the end of this string ...
	return ∗this;
}

Dentro del scope de String<C>, la cualificacion <C> es redundante asi que 
String<C>::String es el nombre del constructor.

*****************************************
***** 23.2.2 Template Instantiation *****
*****************************************
El proceso de generar una funcion o clase a partir de una plantilla se llama 
template instantiation (26.2). Una version para una plantilla para un tipo 
especifico se llama specialization. 
Hay que tener cuidado con no llenar la memoria de definiciones identicas de 
funciones (25.3). 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 23.3 Type Checking @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
El type checking de las templates se realiza despues de que hayan sido 
instanciadas, de la misma manera que si se hubieran hardcodeado las 
especializaciones. Esto puede producir que el usuario del codigo vea errores
con detalles de las templates, que el desconoce lo que es un problema incomodo.
Por esto hay que diseñar las templates para minizar las consecuencias. 
La debilidad principal de las plantillas es que no es posible expresar 
directamente requisitos para sus argumentos. Por ejemplo:
template<Container Cont, typename Elem>
no podemos asegurar con mecanismos propios de c++ que Cont es un contenedor ni 
que Elem es compatible con Elem. Desde c++11 se esta trabajando para ofrecer 
este tipo de comprobaciones en el futuro.
Estas comprobaciones se denominan concepts y se esta trabajando para 
implementarlo en C++ (Gabriel: lo implementan en C++20).
En (24.3) se habla mas sobre concepts y en (24.4) se especifican tecnicas para 
dar soporte a concepts en el codigo.

***********************************
***** 23.3.1 Type Equivalence *****
***********************************
Si hay dos tipos relacionados pero diferentes (por ejemplo herencia) se 
consideran dos tipos diferentes en la plantilla. Por ejemplo:
Shape∗ p {new Circle(p,100)};            // Circle* converts to Shape*
vector<Shape>∗ q {new vector<Circle>{}}; // error : no vector<Circle>* to 
                                         // vector<Shape>* conversion
vector<Shape> vs {vector<Circle>{}};     // error : no vector<Circle> to 
                                         // vector<Shape> conversion
vector<Shape∗> vs {vector<Circle∗>{}};   // error : no vector<Circle*> to 
                                         // vector<Shape*> conversion

Si estas conversiones se hubieran permitido, se producirian errores de tipo 
(27.2.1). Si se quiere permitir estas conversiones, se pueden definir (27.2.2).

**********************************
***** 23.3.2 Error Detection *****
**********************************

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 23.4 Class Template Members @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Igual que una clase, una template class puede tener varios tipos de miembros:
. Data members (variables y constantes) (23.4.1)
. Member functions (23.4.2)
. Member type aliases (23.6)
. static members (function and data) (23.4.4)
. Member types (e.g. a member class) (23.4.5)
. Member templates (e.g.a member class template) (23.4.6.3)
Ademas, una class template puede declarar friends (23.4.7)
Las reglas para los miembros de un template class son los mismo que para una
clase normal.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 23.5 Function Templates @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Cuando se llama a una function template, los tipos de los argumentos de la 
funcion determinan que version de la template usar (23.5.2).

**********************************************
***** 23.5.1 Function Template Arguments *****
**********************************************
Los argumentos de tipo y de no-tipo se deducen por el compilador. Notese que los
class template parameters nunca son deducidos. La razon es por la flexibilidad 
que ofrecen muchos constructores para una clase puede hacer que la deduccion sea
imposible en muchos casos y oscura en muchos otros. En vez de eso, la 
specialization (25.3) provee un mecanismo para escoger implicitamente entre 
definiciones alternativas de una template. Si necesitamos crear un objeto de un
tipo deducido podemos llamar a la funcion que haga la deduccion y la creacion. 
Por ejemplo: 

template<typename T1, typename T2>
pair<T1,T2> make_pair(T1 a, T2 b)
{
	return {a,b};
}

auto x = make_pair(1,2); // x is a pair<int,int>
auto y = make_pair(string("New York"),7.7); // y is a pair<string,double>

Si un argumento no puede ser deducido a partir de los argumentos de la funcion,
debemos especificarlo explicitamente de la misma forma que con las template 
class:

template<typename T>
T∗ create();  // make a T and return a pointer to it

void f()
{
	vector<int> v;          // class, template argument int
	int∗ p = create<int>(); // function, template argument int
	int∗ q = create();      // error : can’t deduce template argument
}

Los template arguments por defecto pueden servir para evitar tener que definir
tantos tipos explicitamente.

*******************************************************
***** 23.5.2 Function Template Argument Deduction *****
*******************************************************
En el libro muestra una tabla con todas las construcciones desde las que se 
pueden deducir los parametros de las templates.

-- 23.5.2.1 Reference Deduction
Puede ser util realizar diferentes acciones para lvalues o rvalues:

template<typename T>
class Xref {
public:
	Xref(int i, T∗ p) // store a pointer: Xref is the owner
		:index{i}, elem{p}, owner{true}
	{}
	
	Xref(int i, T& r)	// store a pointer to r, owned by someone else
		:index{i}, elem{&r}, owner{false}
	{}
	
	Xref(int i, T&& r)	// move r into Xref, Xref is the owner
		:index{i}, elem{new T{move(r)}}, owner{true}
	{}
	
	˜Xref()
	{
		if(owned) delete elem;
	}
	// ...
private:
	int index;
	T∗ elem;
	bool owned;
};

Por lo que:

string x {"There and back again"};

Xref<string> r1 {7,"Here"}; // r1 owns a copy of string{"Here"}
Xref<string> r2 {9,x};      // r2 just refers to x
Xref<string> r3 {3,new string{"There"}}; // r3 owns the string{"There"}

Aqui r1 escoge Xref(int,string&&) porque x es un rvalue.

************************************************
***** 23.5.3 Function Template Overloading *****
************************************************
Se puede declarar muchas function templates con el mismo nombre e incluso 
declarar una combinacion de function templates y funciones ordinarias con el 
mismo nombre. Cuando se llama a una funcion asi, hay que resolver la 
sobrecarga:

template<typename T>
	T sqrt(T);
template<typename T>
	complex<T> sqrt(complex<T>);
double sqrt(double);

void f(complex<double> z)
{
	sqrt(2); // sqr t<int>(int)
	sqrt(2.0); // sqr t(double)
	sqrt(z); // sqr t<double>(complex<double>)
}

Primero se crean las especializaciones de las funciones necesarias, y luego se
juntan con las funciones ordinarias y se aplica las reglas de solucion de 
sobrecarga para todas ellas. Esto se realiza en los siguientes pasos:

1. Encontrar el set de function template specializations que tomara parte en la
resolucion de sobrecarga. Para sqrt(z) , se encuentran como candidatos 
sqrt<double>(complex<double>) y sqrt<complex<double>>(complex<double>).
2. Si dos function templates pueden ser llamadas y una es mas especializada que
otra, solo se considera la mas especializada. Para sqrt(z) la mas especializada
es sqrt<double>(complex<double>) sobre sqrt<complex<double>>(complex<double>) 
porque cualquier llamada a sqrt<T>(complex<T>) tambien funciona para sqrt<T>(T).
3. Hacer resolucion de sobrecarga para este set de funciones, mas las funciones
ordinarias. Si un argumento de la function template ha sido determinado por la 
deduccion de argumentos, ese argumento no puede tener promociones o 
conversiones. Para sqrt(2), sqrt<int>(int) es un match exacto, asi que es 
preferido sobre sqrt(double).
4. Si una funcion y una especializacion son igual de buenas matches, se prefiere
la funcion. Para sqrt(2.0) se prefiere sqrt(double) frente a 
sqrt<double>(double).
5. Si no se encuentra match o se encuentra varios matches ambiguos, la llamada 
es un error.

Por ejemplo:

template<typename T>
T max(T,T);

	const int s = 7;

void k()
{
	max(1,2);     // max<int>(1,2)
	max('a','b'); // max<char>(’a’,’b’)
	max(2.7,4.9); // max<double>(2.7,4.9)
	max(s,7);	  // max<int>(int{s},7) (trivial conversion used)
	
	max('a',1);	// error: ambiguous: max<char,char>() or max<int,int>()?
	max(2.7,4);	// error: ambiguous: max<double,double>() or max<int,int>()?
}

El problema con las dos ultimas llamadas es que no se aplican promociones ni 
conversiones estandar.

-- 23.5.3.1 Ambiguity Resolution
Las ambiguedades se pueden resolver con cualificacion explicita:

max<int>('a',1);    // max<int>(int(’a’),1)
max<double>(2.7,4); // max<double>(2.7,double(4))

Para funciones ordinarias se aplican las reglas de sobrecarga ordinarias y el 
uso de inline asegura que no hay extra overhead.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 23.7 Source Code Organization @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Hay tres formas de organizar el codigo que usa templates:
1. Incluir las definiciones de templates antes de su uso en la unidad de 
traduccion.
2. Incluir las declaraciones de templates unicamente antes de usarlas en la 
unidad de traduccion. Incluir las definiciones mas tarde en la unidad de 
traduccion (potencialmente despues de su uso).
3. Incluir las declaraciones de templates unicamente antes de usarlas en la
unidad de traduccion. Definir las templates en alguna otra unidad de traducicon.

Por razones tecnicas e historicas, la opcion 3 no se ofrece. La opcion mas comun
es incluir con #include la definicion de las templates y esperar a que el 
compilador haga optimizacion de su uso y no las duplique.

En la opcion 2 se declara primero las templates en el .h y luego se definen en 
el .cpp:

// file outdecl.h:
template<typename T>
void out(const T& t);

// file out.cpp:
#include<iostream>
template<typename T>
void out(const T& t)
{
	std::cerr << t;
}

El usuario ahora tiene que incluir ambos: 

// file user3.cpp:
#include "out.h"
// use out()
#include "out.cpp"

**************************
***** 23.7.1 Linkage *****
**************************
Las reglas de linkage para las templates son las mismas que para el resto de 
clases y funciones.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 31.3 Operations Overview @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
En el libro viene una tabla con el overview de todos los contenedores de la STL
y su herencia (muy util).



#####################################
###### 34 Memory and Resources ######
#####################################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 34.2 Almost Containers @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Algunos contenedores no se incluyen en el STL porque tienen ciertas 
restricciones o anaden facilidades para su uso.

Almost containers:
    - T[N] : built-in array. Tamano fijo y allocated. Implicitamente se 
    convierte en T*
    - array<T,N>: como el built-in array pero soluciona varios problemas
    - bitset<N>: secuencia de N bits de tamano fijo
    - vector<bool>: secuencia de bits compactados en una especializacion de 
    vector
    - pair<T,U>: dos elementos de los tipos T y U
    - tuple<T...>: secuencia de tamano arbitrario de tipos arbitrarios.
    - basic_string<C>: secuencia de caracteres del tipo C. Provee de operaciones
    string
    - valarray<T>: array de valores numericos del tipo T. Provee de operaciones
    numericas.


************************
***** 34.2.1 Array *****
************************

Los array ofrecidos en la cabecera <array> son similares a los vectores
salvo que tienen tamano fijo.
Esto supone que algunas operaciones que tienen los vectores no las tienen los
array.

! Mover un array no es mas rapido que copiarlo, porque no se almacena 
informacion sobre como se guardan los datos.

La funcion at(n) devuelve una referencia al elemento en la posicion n y ademas
comprueba que este dentro del rango, a diferencia de []. 
https://cplusplus.com/reference/array/array/at/ 


*************************
***** 34.2.2 Bitset *****
*************************

Un bitset es un set de bits de tamano fijo optimizado para operaciones binarias.
Difiere de un vector<bool> en que este tiene tamano variable.
Se incluye en la cabecera <bitset>.
Es optimo para numeros muy grandes (long long) y generalmente optimo para 
numeros mas pequenos (int).

Por razones historicas bitset difiere en estilo de otras classes de la STL. 
No tiene iteradores. Las posiciones de los bits se numeran de derecha a 
izquierda, como se leeria un byte.


-- 34.2.2.1 Constructors

Los bitset se pueden constuir a partir de unsigned long long int o de string

bitset bs {}; // N zero bits
bitset bs {n}; // Bits from n; n is an unsigned long long
Constructores a partir de string: mirar libro

Cuando se crea con un unsigned long long int, cada bit se inicializa en funcion
del valor de los bits del int.
Cuando se crea con un string, cada bit se inicializa a 0 si vale '0', 1 si vale
'1' y devuelve un error en cualquier otro caso.

Ejemplos: 
void f()
{
bitset<10> b1;                         // all 0

bitset<16> b2 = 0xaaaa;                // 1010101010101010
bitset<32> b3 = 0xaaaa;                // 00000000000000001010101010101010

bitset<10> b4 {"1010101010"};          // 1010101010
bitset<10> b5 {"10110111011110",4};    // 0111011110

bitset<10> b6 {string{"1010101010"}};         // 1010101010
bitset<10> b7 {string{"10110111011110"},4};   // 0111011110
bitset<10> b8 {string{"10110111011110"},2,8}; // 0011011101

bitset<10> b9 {string{"n0g00d"}};  // invalid_argument thrown
bitset<10> b10 = string{"101001"}; // error : no implicit string 
                                   // to bitset conversion
}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 34.4 Allocators @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Los contenedores de la STL y los string usan allocators que proveen una fuente 
de memoria para un tipo determinado y un lugar de retorno de esa memoria cuando
ya no sea necesitada. Las funciones basicas de un allocator son:

p=a.allocate(n);   // acquire space for n objects of type T
a.deallocate(p,n); // release space for n objects of type T pointed to by p

Un allocator simple se podria configurar asi:

template<typename T>
struct Simple_alloc { // use new[] and delete[] to allocate and deallocate bytes
	using value_type = T;

	Simple_alloc() {}
	
	T∗ allocate(size_t n)
		{ return reinterpret_cast<T∗>(new char[n∗sizeof(T)]); }
	void deallocate(T∗ p, size_t n)
		{ delete[] reinterpret_cast<char∗>(p); }
		
	//...
};

Este allocator no usa constructores ni destructores, trabaja directamente con la
memoria. 
Tambien podemos construir un allocator para allocar en un area arbritaria de 
memoria:

class Arena {
	void∗ p;
	int s;
public:
	Arena(void∗ pp, int ss); // allocate from p[0..ss-1]
};
	
template<typename T>
struct My_alloc {
	Arena& a;     // use an Arena to allocate and deallocate bytes
	My_alloc(Arena& aa) : a(aa) { }
	My_alloc() {} // usual allocator stuff
};

Una vez que las Arenas se han creado, se pueden construir objetos en la memoria
allocada:

constexpr int sz {100000};
Arena my_arena1{new char[sz],sz};
Arena my_arena2{new char[10∗sz],10∗sz};

vector<int> v0; // allocate using default allocator
// construct in my_arena1
vector<int,My_alloc<int>> v1 {My_alloc<int>{my_arena1}};
// construct in my_arena2
vector<int,My_alloc<int>> v2 {My_alloc<int>{my_arena2}};
vector<int,Simple_alloc<int>> v3;// construct on free store

Un allocator impone overhead de espacio en un contenedor unicamente si sus 
objetos tienen un estado (como My_alloc). Esto se consigue confiando en la 
empty-base optimization (28.5).

****************************************
***** 34.4.1 The Default Allocator *****
****************************************
Los contenedores de la libreria estandar usan por defecto un allocator que usa 
new y delete. (implementacion en el libro)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 34.5 The Garbage Collection Interface @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
El recolector de basura a veces se presenta como una panacea, pero no lo es. En 
particular, los recursos que no son memoria pura puede ser leakeados por el 
recolector. Por ejemplo file handles, thread handles y locks. 
El autor indica que el recolector es un ultimo recurso conveniente despues de 
aplicar exhaustivamente las tecnicas para prevenir leaks:
	1. Usar resource handles con las semanticas apropiadas para un aplicacion
	siempre que sea posible. La libreria estandar provee string, vector, map,
	etc. Las semanticas de movimiento permiten que estos objetos sean devueltos
	eficientemente por una funcion.
	2. Usar unique_ptrs para guardar objetos que no manejan implicitamente sus
	propios recursos (como los punteros), necesitan ser protegidos de una 
	destruccion prematura (porque no tienen destructores propios), o necesitan
	ser allocados de forma que requieran una especial atencion (deleters).
	3. Usar shared_ptrs para objetos con propiedad compartida.
Si estas tecnicas se usan consistentemente, se previenen leaks sin la necesidad
de un recolector de basura. 
Aun asi, en muchos programas reales, estas tecnicas basadas en RAII (13.3) no se
usan consistentemente porque implican grandes cantidades de codigo estructurado
de diferentes maneras que implican usar naked new o deletes, conversiones 
explicitas y tecnicas de bajo nivel propensas a errores. En estos casos es 
conveniente un garbage collector. Al hacer un garbage collector se pueden 
establecer reglas propias, como controlar el tiempo de vida para cada tipo de 
objeto, asi como tambien se pueden producir leaks especificos de nuestro 
collector.
El estandar de C++ no provee un garbage collector por estos motivos, pero se 
pueden usar algunos compatibles publicos.
Algunos ejemplos donde se podrian producir comportamientos indeseados con un 
collector:

int∗ p = new int[100];
p+=10;
// ... collector may run here ...
p −= 10;
∗p = 10; // can we be sure that the int is still there?

int∗ p = new int;
int x = reinterpret_cast<int>(p); // not even portable
p = nullptr;
// ... collector may run here ...
p = reinterpret_cast<int∗>(x);
∗p = 10; // can we be sure that the int is still there?

int∗ p = new int;
cout << p;
p = nullptr;
// ... collector may run here ...
cin >> p;
∗p = 10; // can we be sure that the int is still there?

[...]

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 34.6 Uninitialized Memory @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
En la mayoria de los casos es mejor evitar la memoria sin inicializar, pero en 
casos concretos como escribir un allocator, implementar contenedores o tratar 
directamente con el hardware, el uso de raw memory es esencial.
En <memory> ademas del allocator estandar, se proveen funciones de la familia 
fill* para tratar con memoria sin inicializar (32.5.6)

************************************
***** 34.6.1 Temporary Buffers *****
************************************
Los algoritmos usualmente requieren espacio temporal para performar 
adecuadamente. Este espacio se alloca en una operacion, pero no se inicializa
hasta que no se requiere una posicion particular de ese espacio. La libreria
provee dos funciones para allocar y deallocar espacio sin inicializar:

// allocate, don’t initialize
template<typename T>
	pair<T∗,ptrdiff_t> get_temporary_buffer(ptrdiff_t);
// deallocate, don’t destroy
template<typename T>
	void return_temporary_buffer(T∗);

La funcion get_temporary_buffer<X>(n) intentar allocar espacio para n o mas 
objetos de tipo X. Si tiene exito devuelve un puntero al primer espacio sin 
inicializar y el numero de objetos de tipo X que cabran en dicho espacio. Si no
tiene exito, el segundo valor es 0.
La idea es tener un sistema para allocacion rapida. La funcion puede devolver 
mas o menos espacios de los pedidos, por lo que una forma de usarla es preguntar
optimistamente por muchos espacios y luego usar los que esten disponibles.

Un buffer obtenido por get_temporary_buffer() debe ser liberado por 
return_temporary_buffer(), que libera sin destruir, como el get adquiere sin 
construir. Como el get es de bajo nivel no debe ser usado como alternativa a 
new o allocator::allocate().

########################
###### 36 Strings ######
########################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 36.1 Introduction @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
La libreria estandar ofrece:
<cctype> para operaciones de clasificacion de caracteres
<string> para strings y sus operaciones
<regex> para expresiones regulares
<cstring> para c-style strings

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 36.2 Character Classification @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

*******************************************
***** 36.2.1 Classification Functions *****
*******************************************
<cctype> ofrece funciones como isspace(c), isdigit(c), isupper(c), etc para 
caracteres basicos. Para wide characters existen las mismas funciones en 
<cwctype>, y para otros locales en <locale>.
El autor recomienda usar estas funciones en vez de hacer comprobaciones 
manuales como if ('a'<ch && ch<'z') // a character, pudiendo hacer 
if (islower(ch))

***********************************
***** 36.2.2 Character Traits *****
***********************************
Un string puede ser en principio cualquier tipo con operaciones de copia, pero
se puede aumentar la eficiencia con tipos simplificados que no tienen 
operaciones de copia definidas por el usuario. Por eso el string estandar 
requiere que el tipo usado como su character type sea un POD (8.2.6). Esto
ayuda a que las operaciones I/O sean simples y eficientes.
Las propiedades de un character type estan definidas por char_traits. Todos los
char_traits estan definidos por el estandar y presentados en <string>. El 
char_traits general no tiene propiedades, solo las tienen los char_traits
especializados. Considerese char_traits<char>:

template<>
struct char_traits<char> {  // char_traits operations should not throw 
                            // exceptions
	using char_type = char;
	using int_type = int;         // type of integer value of character
	using off_type = streamoff;   // offset in stream
	using pos_type = streampos;   // position in stream
	using state_type = mbstate_t; // multibyte stream state (§39.4.6)
	// ...
};

El estandar provee cuatro especializaciones de char_traits:

template<> struct char_traits<char>;
template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;

Los miembros de char_traits estandar son todos funciones estaticas (tabla en el 
libro).

Como copy() on protege de sobreescribir rangos, puede ser mas rapido que move().

@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 36.3 Strings @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@
En <string> esta la template general basic_string. Los elementos (characters) se
almacenan contiguamente. basic_string ofrece strong guarantee (13.2).
Existen especializaciones para algunos tipos estandar de characters:
using string = basic_string<char>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
using wstring = basic_string<wchar_t>;
Al igual que los contenedores, basic_string ofrece move semantics para ser 
eficientemente devueltas por valor.

*********************************************
***** 36.3.1 string vs. C-Style Strings *****
*********************************************
Considerese construir una direccion de email:

string address(const string& identifier, const string& domain)
{
	return identifier + '@' + domain;
}

void test()
{
	string t = address("bs","somewhere");
	cout << t << '\n';
}

Ahora en C-style:

char∗ address(const char∗ identifier, const char∗ domain)
{
	int iden_len = strlen(identifier);
	int dom_len = strlen(domain);
	char∗ addr = (char∗)malloc(iden_len+dom_len+2);
	strcpy(identifier,addr);
	addr[iden_len] = '@';
	strcpy(domain,addr+iden_len+1);
	return addr;
}
void test2()
{
	char∗ t = address("bs","somewhere");
	printf("%s\n",t);
	free(t);
}

En C-style hay que gestionar manualmente la memoria.
A veces se dice que los C-style strings son mas eficientes que std::string, pero
para muchos usos, string hace menos allocations y deallocations que su 
equivalente C-style (debido a small-string optimization y move semantics 19.3.3
y 19.3.1). Tambien strlen() es log(N), mientra que string::size() es una sola
lectura.
La diferencia fundamental es que string es un tipo con semantica convencional, 
mientras que C-style strings es un conjunto de convenciones soportadas por unas
pocas funciones utiles.
Para otras funciones como sort, la version para string es mas idiomatica y
rapida.

Las siguientes notas son para C++14. En C++17 se introduce string_view que 
soluciona estos casos.
Nota Gabriel: he estado haciendo pruebas, y std::string hace alloc para su 
cadena salvo que ocupe menos de x chars (esto se llama small string 
optimization y guarda la cadena en el stack). const char* guarda la cadena en el
stack por lo que para casos concretos controlados puede ser mas eficiente. 
Nota Gabriel: cuando se escribe literalmente "cadena" se considera un const 
char*. Por ejemplo en std::cout << "cadena"; "cadena" en const char* y por tanto
se guarda en el stack. Si se hiciera
std::string cadena {"cadena"};
std:cout << cadena;
El operador << de ostream llama a la sobrecarga de string& porque cadena esta en
el heap.

*******************************
***** 36.3.2 Constructors *****
*******************************
Existen muchos constructores (tabla en el libro) pero lo mas comunes son los
mas simples: 

string s0;                        // the empty string
string s1 {"As simple as that!"}; // construct from C-style string
string s2 {s1};                   // copy constructor

Casi siempre el destructor se invoca implicitamente. No hay string que tome un
numero de elementos fijo:

string s3 {7};     // error : no string(int)
string s4 {'a'};   // error : no string(char)
string s5 {7,'a'}; // OK: 7 'a's
string s6 {0};     // danger : passing nullptr

s6 muestra un error comun cometido por los programadores que suelen usar C-style
strings:
const char* p = 0; // set p to "no string"
Desafortunadamente, el compilador no puede capturar la definicion de s6 o el 
caso mas desagradable de tener un const char* apuntando a nullptr:

string s6 {0};    // danger : passing nullptr
string s7 {p};    // may or may not be OK depending on the value of p
string s8 {"OK"}; // OK: pass pointer to C-style string

Inicializar un string con un nullptr puede llevar a comportamiento indefinido.

Si se intenta construir un string con mas caracteres que los que la 
implementacion permite, se obtiene un error std::length_error. El valor 
string::npos representa la posicion detras de la longitud del string y  se suele
usar para indicar "fin del string". 

*****************************************
***** 36.3.3 Fundamental Operations *****
*****************************************
Un basic_string ofrece operaciones de comparacion (tabla en el libro), y de 
gestion de tamaño y capacidad, que son iguales que las de vector (tabla en el 
libro). Tambien hay operaciones de acceso (tabla en el libro).

No existe conversion implicita de string a char*, en su lugar se ofrece la 
funcion c_str() que convierte explicitamente a const char*.

Un string puede contener un zero value character ('\0'). Usar una funcion como 
strcmp(), que asume convenciones de C-style string, sobre el resultado de 
s.c_str() o s.data() en un string que contienen un zero character, puede causar
sorpresa.

Nota Gabriel: En C los strings son arrays de chars que deben tener como ultimo
caracter un '\0'. Las funciones de la libreria de c usan este caracter para 
saber donde acaba el string, y los programadores tambien deben tenerlo en cuenta
al escribir funciones. En C++, std::string tiene internamente un buffer que 
termina en '\0' para compatibilidad con C, pero su size() indica el numero de 
caracteres sin tener en cuenta este caracter nulo. Cuando se pide el puntero al
buffer con data() o c_str(), el puntero es como un C-style string dado que 
acaba en '\0'.
 

*****************************
***** 36.3.4 String I/O *****
*****************************
Un basic_string puede ser escrito usando << y >>. Estas operaciones realizan 
comprobaciones y pueden lanzar errores. Tambien se pueden concatenar dado que 
devuelven referencia al input stream.

**************************************
***** 36.3.5 Numeric Conversions *****
**************************************
En <string> hay funciones que permiten extraer valores numericos de un string o
wstring (no basic_string). (tabla en el libro).
El autor indica que prefiere usar string_stream (38.2.2) para este tipo de 
operaciones.

**************************************
***** 36.3.6 STL-like Operations *****
**************************************
basic_string provee el usual set de iteradores (ver tabla en el libro). Como 
tiene los miembros y funciones requeridos para obtener iteradores, los strings
se pueden usar junto con los algoritmos standar (ch. 32). Aun asi, las funciones
provistas para strings suelen estar optimizadas para strings, para que no se 
tenga que aplicar algoritmos estandar. Los algoritmos generales tienden a asumir
que los elementos de un contenedor son significantes aisladamente. Este no es
el caso tipico de un string. 
Un basic_string ofrece complejos assignment() y operaciones de insercion y 
delete (tablas en el libro). 
Al igual que los vectores, es tipicamente mas eficiente append() que insert().

**********************************
***** 36.3.7 The find Family *****
**********************************

*****************************
***** 36.3.8 Substrings *****
*****************************









############################
###### 38 I/O Streams ######
############################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 38.2 The I/O Stream Hierarchy @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

*******************************
***** 38.2.1 File Streams *****
*******************************

En <fstream> la libreria estandar provee streams para ficheros:
 - ifstreams : para leer de un fichero
 - ofstreams : para escribir en un fichero
 - fstreams : para leer y escribir en un mismo fichero

Operaciones: 
fstream fs {}; //fs is a file stream not attached to a file
fstream fs {s,m}; //fs is a file stream opened for a file called s with mode m;
                    s can be a string or a C-style string
fstream fs {fs2}; //Move constructor: fs2 is moved to fs; fs2 becomes unattached
fs=move(fs2) //Move assignment: fs2 is moved to fs; fs2 becomes unattached
fs.swap(fs2) //Exchange the states of fs and fs2
p=fs.rdbuf() //p is a pointer to fs’s file stream buffer (basic_filebuf<C,Tr>)
fs.is_open() //Is fs open?
fs.open(s,m) //Open a file called s with mode m and have fs refer to it;
               sets fs’s failbit if it couldn’t open the file;
               s can be a string or a C-style string
fs.close() //Close the file associated with fs (if any)

Los file stream no tienen operaciones de copia.

Hay seis file streams alias definidos en <fstream>:
using ifstream = basic_ifstream<char>;
using wifstream = basic_ifstream<wchar_t>;
using ofstream = basic_ofstream<char>;
using wofstream = basic_ofstream<wchar_t>;
using fstream = basic_fstream<char>;
using wfstream = basic_fstream<wchar_t>;


Stream modes:
ios_base::app    //Append (i.e., add to the end of the file)
ios_base::ate    //‘‘At end’’ (open and seek to the end)
ios_base::binary //Binary mode; beware of system-specific behavior
ios_base::in     //For reading
ios_base::out    //For writing
ios_base::trunc  //Truncate the file to 0 length

Nota: el modo binario es recomendable para leer archivos sin interpretar su
contenido. El modo in en algunos SO puede interpretar y modificar ciertos 
caracteres como \n y transformarlos en \r\n (Windows).

Ejemplos:
ofstream ofs("target"); // ‘‘o’’ for ‘‘output’’ implying ios::out
if (!ofs)
    error("couldn't open 'target' for writing");

fstream ifs; // ‘‘i’’ for ‘‘input’’ implying ios::in
ifs.open("source",ios_base::in);
if (!ifs)
    error("couldn't open 'source' for reading");

*******************************
***** 38.4.4 Stream State *****
*******************************
En <ios> la libreria estandar define una clase base ios_base que hace de 
interfaz para una clase stream. basic_ios hereda esta interfaz.
basic_ios maneja el estado de un stream: 
 .El mapping entre un stream y sus buffers (38.6)
 .Las opciones de formateo (38.4.5.1)
 .El uso de locales (ch. 39)
 .Error handling (38.3)
 .Conexiones con otros streams y stdio (38.4.4)
ios_base contiene informacion que no depende de los argumentos de la template.
ios_base controla la conexion de iostream a stdio.

Una llamada a sync_with_stdio(true) antes de la primera operacion de iostream
garantiza que las operaciones de iostream y stdio compartiran buffers. Si se 
indica false, no compartiran buffers, lo que aumentara el rendimiento en algunas
implementaciones. Notese que ios_base no tiene operaciones de copia o 
movimiento. 
En el libro hay tablas con los miembros iostate ,openmode, seekdir y las 
operaciones de basic_ios.

Una clase ios es convertible a bool, y se hace implicitamente al encadenar 
operaciones como >>, para comprobar siempre que el estado del stream es valido.

@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@ 38.6 Buffering @@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@
Conceptualmente, un output stream pone los caracteres en un buffer, que despues 
son escritos a donde se suponga que deban ir. Este buffer se llama streambuf.
Su definicion se encuentra en <streambuf>. Tipicamente los caracteres se 
almacenan en un array hasta que haya un overflow y se escriban a su destino 
real. (esquema en el libro)

Los argumentos de un ostream y su streambuf deben ser iguales para poder 
determinar el tipo de caracteres usados en el buffer.

Unbuffered IO es IO donde streambuf inmediatamente transfiere cada caracter en 
vez de guardarlos hasta que el buffer esta lleno.

La clase clave en los mecanismos de buffering es basic_streambuf. Como es usual,
se proveen alias de los casos mas comunes:

using streambuf = basic_streambuf<char>;
using wstreambuf = basic_streambuf<wchar_t>;

En el libro se muestran los diferentes metodos.

#########################
###### 40 Numerics ######
#########################

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 40.7 Random Numbers @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

En la libreria <random> se ofrecen mecanismos para generar numeros pseudo 
aleatorios. Se proveen 4 tipos de entidades:
 - uniform random number generator: funcion que devuelve un numero aleatorio 
 en un rango donde todos los numeros tienen idealmente las mismas 
 posibilidades de salir.
 - random number engine (engine): es un uniform random number generator que 
 puede ser inicializado por defecto o a partir de una semilla.
 - random number engine adaptor (adaptor): es un engine que toma valores 
 producidos por otros engines y les aplica un algoritmo para entregar una 
 secuencia de numeros con diferentes propiedades aleatorias.
 - random number distribution (distribution): devuelve valores numericos que han
 sido distribuidos acorde a una funcion de densidad p(z) o de probabilidad P(zi)
 

**************************
***** 40.7.1 Engines *****
**************************

Un random number engine es un uniform random number generator con propiedades 
adicionales que lo hacen mas practico de utilizar. Los engines se pueden 
inicializar con una semilla.

Existen algunos alias predefinidos para engines utiles como std::mt19937 que 
crea una engine basada en el mersenne twister. 


********************************
***** 40.7.2 Random Device *****
********************************

Un random device es un generador de numeros aleatorios verdaderos que utiliza 
hardware dedicado cuando sea posible para generar estos numeros. Por ejemplo, 
algunos procesadores Intel y AMD tienen instrucciones y hardware dedicado para
generar numeros aleatorios que utilizan variables fisicas aleatorias como el 
ruido. Un random device utiliza estas instrucciones si es posible u otros 
algoritmos en caso de no ser posible. Este proceso es costoso en comparacion con
la generacion de numeros pseudo aleatorios, por eso random_device suele usarse
como semilla para inicializar otros generadores o en aplicaciones criptograficas

-- Notas 

En resumen, para generar numeros aleatorios para la mayoria de casos se necesita
un random device para generar un numero aleatorio verdadero que se utiliza como
semilla para inicializar un generador de numeros pseudoaleatorios (pe mt19937) y
a este se le puede aplicar una distribucion que indique el rango y la 
probabilidad de los numeros que puede generar (pe. distribucion uniforme de int)

Ejemplo para generar enteros en un rango con una distribucion uniforme:

std::random_device rd {}; // generador de num. rand. verdaderos (costoso)
std::mt19937 gen(rd());   // inicializacion del generador pseudo rand.
std::uniform_int_distribution<int> dist(1,6); // crear la distribucion
int random_number = dist(gen); // generacion del aleatorio en la distribucion 



#######################################
###### 43 The C Standard Library ######
#######################################

@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 43.2 Files @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@

Un file (FILE*) puede referirse a un fichero o un stream standard (stdin, 
stdout y stderr).
Los standard stream se abren por defecto, el resto de ficheros hay que abrirlos

Un fichero que se abre con fopen se cierra con fclose. Si no se usa fclose el 
fichero queda abierto y lo tiene que cerrar el OS. Esto es considerado un leak
y por eso se recomienda usar fstream en C++ (Seccion 38.2.1).

Los File Modes para abrir un file (y tambien streams de iostream) son:
 - "r" : Reading
 - "w" : Writting
 - "a" : Append
 - "r+" : Reading and Writting
 - "w+" : Reading and Writting (discard previous contents)
 - "b" : Binary, usar junto a otros modes

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@ 43.3 The printf() Family @@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
La familia de printf() es:

n=printf(fmt,args)    // f = stdio
n=fprintf(f,fmt,args)
n=sprintf(s,fmt,args)

donde n es el numero de caracteres impresos, f un fichero, s un string, fmt el
formato, y args los argumentos.

Los diferentes formateadores (%) estan especificados en el libro.

printf() se considera insegura porque no hace type checking de sus argumentos.
Ademas, no puede imprimir tipos definidos por el usuario como complex, vector,
etc.

El C standard IO y los C++ IO streams tienen una correspondencia muy cercana y 
pueden compartir buffer. Por ejemplo, se puede mezclar cout y stdout para 
producir un unico output stream, pero esto lleva un coste de rendimiento. Para 
evitar este coste se puede indicar ios_base::sync_with_stdio(false) antes de la
primera operacion de IO (38.4.4).

Para las funciones de C, recomienda no usar gets o scanf de %s, porque son dadas
a virus. En su lugar recomienda usar las funciones "_s" que incorpora C11.	












-------------
----- NOTAS PARA AGREGAR CUANDO LEA CIERTOS CAPITULOS
-------------

std::cout, std::cin y std::log son buffered. std::cerr no es buffered. 
std::cerr hace flush inmediato al SO, lo que garantiza que las cadenas se van 
a ver aunque la aplicacion falle despues. Los buffered por otra parte son mas
rapidos porque hacen flush cuando el buffer esta lleno, lo que implica menos 
llamadas al vaciado en el SO.



























